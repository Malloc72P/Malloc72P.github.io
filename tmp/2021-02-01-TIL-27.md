---
sort: -27
title: TIL-27, 스물일곱번째.
tags: [ TIL ]
---

# 오늘 할 일

- [x] 네트워크 계층에 대해 학습한다.
- [ ] 서버클라 구조랑 URL과 DNS에 대해 공부하기
- [ ] HTTP에 대해 공부하기
- [ ] 공부한 내용을 가지고 실습하기
- [ ] 다이나믹 프로그래밍 공부하기
- [ ] 토끼책 읽기
- [ ] SQL책 읽기

# 오늘 배운 내용  

### 오늘의 목표

* URL에 대해 공부하고, 구조를 이해한다
* HTTP프로토콜에 대해 공부하고, 패킷의 구조를 이해한다
* DNS를 통해 문자 이름으로 IPv4나 IPv6주소를 획득하는 과정에 대해 공부한다.
* 자바를 이용한 소켓프로그래밍을 공부한다.

### 오늘의 계획

* URL에 대해 공부한다
* HTTP 프로토콜에 대해 공부한다
* JAVA에서 소켓 프로그래밍하는걸 공부한다
* URL과 HTTP프로토콜에 대해 배운걸 가지고 JAVA프로그램으로 구현해본다.

### 키워드

* 자바 API. java.net.InetAddress
* 자바 소켓 java.net.Socket

## 네트워크 기초

> **참조한 책 : TCP-IP가 보이는 그림책. 성안당, 글쓴이 : ANK CO.,Ltd 저**

#### 네트워크를 계층(Layer)으로 나누는 이유 : 계층화를 하는 이유

네트워크 통신은 정말 어렵다. 출발지부터 목적지까지 데이터를 보내는 일만 잘 하면 되는데, 이걸 잘 하는게 정말 어렵다. 어디 한군데라도 문제가 생기면 아예 안돌아가기 쉽다. 그래서 똑똑한 사람들은 네트워크 통신이라는 크고 복잡한 문제를 분할해서 정복하기로 했다.

그래서 5계층으로 나뉘었다. 각 계층은 자신들에게 주어진 역할만 완벽하게 수행하면 된다. 그리고 각각의 계층들이 서로 협력해서 네트워크 통신이라는 크고 복잡한 문제를 보다 쉽게 처리할 수 있는 것이다.

```note
계층화 안된 경우
어라, 문제가 생겼네? 근데 어디서 생긴거지??? 아...... 하나씩 다 봐야겠다......
계층화가 된 경우
야 응용프로그램은 문제없니? 없다구?
그럼 전송계층쪽 문제인가? 없다구?
그럼 네트워크계층쪽 문제인가? 아 여기서 문제가 생겼네! 그럼 여기에 해당하는 장비에 문제가 있는지 살펴보자! 와!
```

보통 이걸 OSI 7계층으로 나누는 경우도 있는데, 5계층으로 좀 더 쉽게 나누는 경우도 있다. 일단 5계층으로 추상화한걸 공부하려고 한다.

#### 네트워크 계층과 통신

네트워크 통신을 쉽게 하기 위해 여러 계층으로 분할했다. 각각의 계층이 자신의 역할을 잘 하고 있다면, 그 다음으로 할일은 계층끼리 협력하는 일이다. 각 계층은 자신의 책임을 다하고, 그 결과를 다음 계층에게 전달해야 한다. 마치 이어달리기하는 것 처럼, 데이터를  인접한 계층에게 넘기는 일을 반복해서 목적지까지 데이터가 잘 도착할 수 있게 한다.

#### 데이터가 전송되고 수신되는 과정

##### 응용 계층 : 애플리케이션 레이어 ( HTTP, SMTP 프로토콜, 그 외에도 엄청 많음)

응용계층부터 시작한다. 얘는 우리가 만드는 프로그램이다. 상대 측 응용 프로그램에게 어떤 데이터를 보내려고 한다. 이걸 프로토콜에 맞게 잘 만들어서 전송한다. 그러면 전송계층에게 전달된다.

##### 전송계층 : 트랜스포트 레이어 ( TCP, UDP 프로토콜 )

전송계층은 서로 다른 컴퓨터에서 동작하는 응용끼리 논리적으로 통신할 수 있도록 도와주는 역할을 맡는다. 전송에도 여러가지 방법이 있다. 어떤 경우엔 신뢰성이 있는 전송이 필요할 수 있고, 어떤 경우엔 신뢰성은 좀 포기하더라도 속도가 우선되는 경우도 있다. 전자는 TCP, 후자는 UDP라는 전송계층의 프로토콜이다. 따라서 응용프로그램을 만드는 개발자는 신뢰성 있는 통신이 필요하다면, TCP프로토콜을 쓰면 된다. 그러면 신뢰성있는 통신을 할 수 있다.

신뢰성있는 통신을 하거나 속도 우선의 통신을 하는 등의 논리적인 통신을 도와주는 역할은 전송계층이 맡았다. 그럼 이제 뭘 해야 할까? 수신측에게 데이터를 전송해야 한다. 근데 수신측이 어디있는지 알고 보낼까? 우리는 수신측까지의 경로를 찾고, 거기까지 데이터를 전달하는 역할을 맡아줄 계층이 필요한데, 그게 네트워크 계층이다.

##### 네트워크 계층 : 네트워크 레이어 ( IP프로토콜 )

송신측으로 부터 수신측까지 데이터를 전달하기 위해서, 경로를 찾고 패킷을 전달하는 역할을 맡는다. 경로가 있으려면 일단 송신측이랑 수신측이랑 연결되어 있어야 한다. 그러면 인터넷을 쓰면 된다. 전 세계의 거의 대부분의 컴퓨터는 인터넷을 통해 네트워크에 연결되기 때문이다. 그래서 **인터넷 프로토콜(IP프로토콜)**을 써서 수신측, 즉 목적지까지의 경로를 결정하고 전달하면 된다. 그러면 인터넷이라는 거대한 네트워크에서 목적지까지 경로를 잘 찾아서 전달될 것이다.

물론 내 컴퓨터에서 목적지까지의 경로를 싹 다 찾아서 전달할 수 없다. 네트워크는 수많은 라우터들로 구성되어 있고, 네트워크의 끝자락에는 송신측과 수신측 컴퓨터가 있다. 목적지까지의 경로를 찾는다는건, 어떤 라우터들을 거쳐야 안전하고 빠르게 갈 수 있는지를 찾는것이다. 

네트워크 계층은 경로를 찾아서 결정하고 전달하는 역할을 맡았다. 이제 남은건 물리적으로 데이터를 전송하는 일이다. 컴퓨터와 라우터, 라우터와 라우터간에 데이터를 주고 받으려면 일단 서로 연결이 되어 있어야 한다.  이 역할은 데이터링크 계층에서 맡는다.

##### 데이터링크 계층 : 데이터링크 레이어

기기들을 연결하는것도 여러 방법이 있다. 그래서 기기마다 여러 방법으로 연결되어 있다. 방법이 다양한 만큼, 각각의 연결마다 어떠한 차이점이 생길 수 있다. 근데 이런 차이가 상위계층에 영향을 준다면 정말정말 프로그래밍하기 끔찍하겠다. 그치만 걱정할 필요가 없는게, 데이터링크 계층은 상위계층이 다양한 연결방식에 따른 차이를 의식하지 않고 작동할 수 있게 도와준다. 그래서 네트워크 계층과 물리계층간의 중계자 역할을 한다고 볼 수 있다.

장치간 연결하는 방법을 제공하는 역할은 데이터링크계층이 맡았다. 여기까지 오는데 획득한걸 정리해보자

* 전송할 데이터를 만들었다.
* 전송방식을 정했다. 신뢰성 우선, 또는 속도를 우선하는 전송방식을 할 수 있게 되었다.
* 목적지까지의 경로를 찾고 결정하고, 내보낼 수 있게 되었다.
* 장치 간 연결을 할 수 있게 되었다.

이제 물리적으로 보내야 한다. 데이터는 이진수로 되어 있고, 이걸 물리적으로 잘 전달하고 받을 수 있어야 한다.

##### 물리계층 : 하드웨어 레이어

물리적인 데이터 전송을 위해 비트열과 신호의 변환을 통해 데이터를 주고 받는다. 이 방법은 기기가 갖고 있는 성질에 의존하기 때문에 정해진 프로토콜도 없는데다가, 다른 계층과 성질이 달라서 데이터링크계층의 일부로 생각하거나 TCP/IP계층에서 제외하기도 한단다.

![image-20210201122158536](image-20210201122158536.png)

그림으로 표현하면 이렇다. 데이터를 전송하면 각 계층을 타고 내려가면서 헤더가 붙는다. 각 계층마다 자신의 책임을 다하기 위해 붙이는 것이다. 하위로 내려갈수록 헤더가 붙고, 상위로 올라갈 수록 헤더를 까서 먹는다. 헤더에 기록된 내용대로 수신된 패킷을 처리하는 것이다. 처리하고 나면 더이상 필요없으니까 헤더를 때어준다.

## 서버와 클라이언트. 그리고 URL과 도메인

### 서버-클라이언트 구조

네트워크 프로그램을 만들면 어떤 구조가 생기는데, 그 중 하나가 서버 클라이언트 구조이다. 서비스를 제공하는 서버와, 서비스를 제공받는 클라이언트로 나뉘는 구조이다. 웹의 기준으로 본다면, "어떤 페이지를 주세요" 하고 서비스를 요청하는 웹브라우저가 클라이언트가 되고, 이 요청을 받아서 웹페이지를 응답해주는 웹 **서버**가 있다.

그러면 클라이언트는 서버에게 요청을 할 수 있어야 한다. 가령, 위키에서 "행복"이라는 문서를 보고 싶다. 그러면 이 문서를 요청해야 한다. 어떻게 해야 요청할 수 있을까?

### URL : Uniform Resource Locator

[추가참조](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Identifying_resources_on_the_Web)

URL을 쓰면 네트워크 상에서,  어떤 자원의 위치를 표시할 수 있다. 그래서 URL을 이용해서 서버에게 어떤 자원을 요청할 수 있다.

URL은 아래와 같이 표현된다

```
[Scheme][Domain_Name][:PortNumber]/this/is/my/path/something.ext
예시
http://www.disney.co.kr/home/index.jsp
```

##### 스킴 : Scheme OR 프로토콜 : Protocol

스킴이라고 하거나, 프로토콜이라고도 부르는 이것은, 해당 자원을 요청하기 위해 써야 하는 프로토콜을 말한다. http라면 http프로토콜을 써야하고, ftp면 ftp를 써야 한다.

##### 도메인 이름 ( Domain Name )

서버를 나타낸다. 그래서 IPv4주소를 대신 넣어도 되긴 된다. 다만, 불편하니까 도메인 이름으로 쓴다.

##### 포트번호

애플리케이션 프로토콜을 식별할 수 있는 번호이다. 근데 http는 보통 80포트를 쓰고 https는 443포트를 써서, 안써도 프로토콜을 가지고 판단한다. http를 썼는데 포트번호 안쓰면 당연히 80포트겠지 하고 80포트로 요청한다.

##### 경로

서버상에서 파일이 있는 경로이다.

##### 파일명

그 경로에 있는 파일의 이름이다. 생략가능하다고 한다.

## 도메인 네임 시스템 | DNS

참고자료

> [도메인 네임 시스템](https://ko.wikipedia.org/wiki/%EB%8F%84%EB%A9%94%EC%9D%B8_%EB%84%A4%EC%9E%84_%EC%8B%9C%EC%8A%A4%ED%85%9C)   [네임서버](http://www.ktword.co.kr/abbr_view.php?nav=2&m_temp1=1486&id=1071)   [최상위 도메인](https://ko.wikipedia.org/wiki/%EC%B5%9C%EC%83%81%EC%9C%84_%EB%8F%84%EB%A9%94%EC%9D%B8#%EA%B5%AD%EA%B0%80_%EC%BD%94%EB%93%9C_%EC%B5%9C%EC%83%81%EC%9C%84_%EB%8F%84%EB%A9%94%EC%9D%B8%28ccTLD%29)   [2단계 도메인](https://ko.wikipedia.org/wiki/2%EB%8B%A8%EA%B3%84_%EB%8F%84%EB%A9%94%EC%9D%B8) [TLD와 TLD Name서버](https://dnsmap.io/articles/what-are-top-level-domain-(tld)-name-servers)	
>
> [생활코딩 도메인과 네임서버](https://opentutorials.org/module/288/2802)

### 호스트 네임과 도메인 네임

#### 호스트를 표현하는 방법

URL에서 어떤 서버, 즉 **호스트**를 나타내려면, **IP주소나 도메인 네임**으로 표현할 수 있다. 근데 IP주소로 표현하면, 사람 입장에서 구분하기도, 외우기도 힘드니, 너무 싫다. 하지만 www.youtube.com같이 문자로 된 주소라면 쓰기 좋다. 이러한 문자열을 **호스트 네임**이라고도 부른다.

그렇다보니, 이러한 호스트의 도메인 이름을 네트워크의 주소로 바꿔주거나, 그 반대의 변환을 해줄 수 있는 시스템이 필요하다. 호스트네임으로 직접 서버에 접근하는건 안된다. 호스트네임자체는 인터넷 네트워크 상에서 해당 호스트의 위치를 나타내는 정보를 갖고 있지 않기 때문이다. 그냥 이름일 뿐이다. 그래서 네임서버한테 "이 호스트네임의 IP주소를 아시면 알려주세요"하고 요청해야 한다. 그러면 네임서버가 IP주소를 알려줄 것이고, 이걸로 접근할 수 있다.

이러한 시스템을 DNS라고 부르고, 도메인 이름과 네트워크 주소(IP주소)간의 변환 서비스를 해주는게 네임서버다.

#### 네임서버의 역할

> ![img](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/288/1016.gif) 
>
> *출처 : 생활코딩 : 도메인과 네임서버* [링크](https://opentutorials.org/module/288/2802)

근데 네임서버는 여러 계층으로 구성되어 있다.

#### 네임서버들의 계층관계

* 도메인 이름으로 서버에 접속하기 위해서, 네임서버가 필요하다.
* 그런데 네임서버는 여러 계층으로 분산되어있다. 왜 그럴까?

##### 네임서버는 계층구조로 구현된 분산 데이터베이스이다.

만약에 네임서버가 하나라고 생각해보자. 전 세계의 사람들이 인터넷을 쓰는데다가 호스트네임으로 서버에 접근하니까, 하나의 네임서버는 전세계의 요청을 처리해야 한다. 할 수 있을리가 없으니, 계층구조로 나누고 분산시킨 것이다.

##### 네임서버의 계층구조

* 루트 DNS 서버 (Root Name Server)
  * **최상위 레벨 도메인(Top Level Domain, TLD)**을 알고 있는 네임서버이다.
* 중간 네임서버
  * 책임 네임서버의 IP주소를 알고 있는 중간에 끼어있는 네임서버이다.
* 책임 네임서버 (Authoritative DNS Server)
  * 어떤 호스트의 DNS정보를 갖고 있는 서버이다. 
* 

> ![img](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/288/1019.png) 
>
> *출처 : 생활코딩 : 도메인과 네임서버* [링크](https://opentutorials.org/module/288/2802)

그림으로 그려보면, 저렇게 맨 위에 루트 네임서버가 있다. 전 세계에서 13개 있다고 한다.

그 아래로 com이나 kr과 같은 최상위 레벨 도메인이 있고, 그 아래로는 google이나 go같은 도메인의 네임서버가 있다. 

### 네임서버로 부터 IP주소를 얻는 과정

그래서 도메인 이름으로 IP주소를 찾을 수 있는 방법이 제공된다. 이 역할을 해주는게 바로 네임서버이다. DNS는 계층구조로 구현된 분산 데이터베이스라서, **네임서버에 대한 반복적 질의**를 통해 IP주소를 획득할 수 있다. 



## 마스터즈 클래스

유닉스의 탄생이라는 책이 재밌다고 마스터께서 말씀하셨다.

소켓통신을 통해서 입력한 도메인 네임의 IP주소를 획득하고, 그 주소로 요청해서 페이지를 받아와야 한다.

# 코딩일일결산

#### 내일의 나에게 보내는 전달사항

* 
* 

#### GOOD

* 

#### BAD

* 

 

