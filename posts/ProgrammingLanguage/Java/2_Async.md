---
sort: 2
title: 비동기 처리와 동기처리
tags: [ java, async ]
---



## 작업의 완료에 따른 구분

내 생각엔, 동기함수와 비동기함수의 차이점은, **요청한 작업의 완료**에 대한 **처리방식**인 것 같다.

### Synchronous : 작업요청의 완료를 동기적으로 처리한다

요청한 작업이 완료될때까지 **기다린다**. 완료되면 리턴된 결과를 받아서 **완료에 대한 처리작업**을 한다.

### Asynchronous : 작업요청의 완료를 비동기적으로 처리한다.

작업을 **요청만 하고 다른 작업을 처리**한다. **나중에 요청한 작업이 완료되면,** 그때가서 완료에 대한 처리작업을 한다.

```note
동기 비동기 개념이 왜 필요할까?

어떤 작업을 누군가에게 요청했다고 치자. 요청된 작업이 완료되었을 때, 어떻게 처리할까? 그 작업이 완료되었다는걸 어떻게 해야 알 수 있을까?

첫번째 방법 : 그 작업이 완료되기를 기다린다. 완료되어 결과가 리턴되면 그걸 받아서 처리한다.
이 경우가 동기적인 함수라고 생각한다.

근데 이 방법은 한가지 문제가 있다. 만약 그 작업이 오래 걸리는 작업이라면? 

네트워크 요청이나 시간이 좀 걸리는 연산작업이 있다고 치자. 이게 다 끝날때까지 기다린다면, 그 시간만큼 그 스레드는 블로킹된다. 처리할 작업이 많은 상황에서 이렇게 놀고있으면 괜찮은걸까? 안괜찮다. 아무것도 안하고 기다린다는건 그만큼 CPU를 놀게 만든다는걸 의미한다. CPU는 계속해서 쉬지않고 의미있는 일을 해야 한다. 우리는 절대 CPU가 노는 꼴을 볼 수 없다.

그래서 비동기 처리를 위해 필요한건, 시간이 걸리는 작업은 요청만 해야 한다는것이다. 요청만 하고, 다른 작업을 계속 처리해야 한다. 나중에 가서 요청작업이 완료되었을 때, 그때가서 완료에 대한 처리를 해주면 된다.

근데 그 완료는 어떻게 알까? 동기적인 요청은 완료할때까지 기다리면 되는거였으니까 쉽다. 근데 이건? 완료를 어떻게 알지? 아무래도 비동기처리의 어려운 점은 이 부분이 아닐까 라는 생각이 든다. 비동기 작업의 완료를 어떻게 알고, 그 시점에 딱 맞춰서 완료에 대한 처리작업을 해줄 수 있을까?

비동기 작업을 하고 있는 애는 이 작업의 완료를 알 수 있다. 애초에 얘가 일하고 있는거니까, 그 작업의 완료를 알 수 있다. 그러니 얘한테 작업완료시 실행할 콜백함수를 넘기면 되는게 아닐까?
```

## Non-Blocking과 Asynchronous에 대한 내 생각

### non-blocking

논블로킹은 기다리지 않을 뿐이다. 요청을 해도 거의 즉시 결과를 리턴한다. 그럼 시간이 오래걸리는 작업은 어떻게 하라는걸까? 

요청에 대한 결과에 "아직 안끝났음"을 추가하면 된다.

##### 예제 : 편지함에 편지가 왔을까?

블로킹 방식이면 이렇게 된다. 

```
--->(블로킹)편자함에 편지가 올때까지 기다린다...---10년째 기다림...---편지들어옴--->편지를 읽는다
```

편지함에 편지가 들어오지 않으면 저기서 계속 블로킹되어있다. 대기중인 것이다. 10년동안 밥도 못먹고 편지함만 봐서 배가 너무 고프다.

반면 논블로킹 방식이면 이렇게 된다.

```
--->(논블로킹)편지함을 확인한다---안왔네---밥먹어야지---편지함확인---안왔네---밥먹---편지함확인---왔네---편지일기---밥먹---~~
```

편지함을 확인하지만, 블로킹되지 않는다. 논블로킹이니까. 편지없다는 결과가 바로 리턴된다. 그럼 다른 일을 한다. 그 다음에 또 편지함을 확인한다. 논블로킹이니까 즉시 안왔다는 결과가 리턴된다. 다른일을 한다... 이렇게 해서 어떤 작업때문에 블로킹되지 않고 다른 작업도 처리할 수 있다.

### 그러면 비동기는 왜있는걸까? 둘의 차이점은 뭐지?

내 생각엔, 효율의 문제가 아닐까 라는 생각이 든다. 작업의 완료(편지함에 편지가 들어왔다)를 알아채기 위해 끊임없이 확인해야 한다. 프로그래밍으로 치면, 계속해서 루프를 돌면서 넌블로킹 함수를 호출해야 한다. 만약 1억번을 호출했는데 그 중 단 한번을 제외한 모든 경우가 "아직 안끝났다"는 결과라면, 그만큼 CPU를 낭비한 셈이 된다. 대신 비동기 함수를 쓰면, 그 작업이 완료되었을 때 콜백함수가 호출되어 처리해주기 때문에, 논블로킹처럼 매우 잦은 함수호출이 필요없다. 이 점이 비동기함수의 강점이 아닐까 라는 생각이 든다.

### 비동기는 언제 쓸까?

##### 네트워크 요청 

통신은 시간이 오래 걸린다. 그래서 멍때리면서 응답을 기다릴 수 없다. 기다리지 말고 다른 작업을 하고 있어야 한다.

##### 오래 걸리는 작업

현재 스레드에서 안하고 다른 스레드에게 위임한다. 완료되면 그때가서 처리할 수 있도록 한다.

##### 멀티스레드 개선

적은 스레드로 효율적으로 프로그래밍하기 위해 사용. 블로킹 방식의 개선이 필요할 때. 적절한 스레드 개수를 유지하면서 개발해야 하기 때문이다.