---
sort: 1
title: 협력하는 객체들의 공동체
tags: [ OOP, 객체지향의_사실과_오해 ]
---

#### 주의, 해당 포스트는 책의 내용을 그대로 담은것이 아닌, 책을 읽고 나서 느낀 제 생각을 정리한 것 입니다. 따라서 책의 저자가 전달하고자 한 내용과 다소 차이가 있거나 잘못된 내용이 있을 수 있습니다.
#### 잘못된 내용이 있다면 이메일을 남겨주세요. : scra1028@gmail.com

## 협력하는 객체들의 공동체

### 오해

객체지향의 목표는 실세계를 모방하는게 아니라, 새로운 세계를 창조하는 것이다.

단순히 실세계를 모방한 프로그램을 만들라는게 아니다.

쓰는 사람이 만족할 수 있는 새로운 세계를 창조해야한다.

그런데 왜 실세계를 모방해야한다고 생각한걸까?

실세계를 모방하는게 객체지향을 이해하고 배우는데 효과적이니까.

객체지향이라는 용어에 담긴 기본사상을 이해하는데 있어서, 실세계를 모방한다는건 매우 효과적

그렇지만 비현실적이다. 실무적인 관점에서는 부적합하다고 한다.

그래도 실세계를 모방하는건 객체지향을 이해하는데 도움이 되니까 한번 해보자

### 객체들의 협력(Collaboration)

개인의 힘에는 한계가 있다.

그래서 여러 사람이 모여서 공동체를 이룬다.

객체들도 마찬가지다. 하나의 객체가 모든것을 할 수 없다.

어떤 일을 하고 싶지만 나는 할 수 없다. 그러면 이걸 할 수 있는 객체한테 **요청**해야한다.

그러면 그 객체는 **요청**을 받고, 자신에게 주어진 **책임**을 다한다. 즉, 서비스해준다.

그런 다음 요청한 객체에게 **응답**해준다.

### 역할과 책임

공동체의 구성원들은 저마다 **역할**이 있다.

어떤 사람의 **역할**은 경찰관이다. 이 사람에겐 나쁜사람을 잡아야 한다는 **책임**이 있다.

어떤 사람의 **역할**은 소방관이다. 이 사람에겐 화재를 진압해야 한다는 **책임**이 있다.

이렇듯, 어떤 공동체의 구성원에게 **역할**이 부여됨에 따라, 자연스럽게 **책임**이 부여된다.

객체도 마찬가지이다. 객체에도 특정한 **역할**이 부여된다. 또한 이 역할로 인해 어떤 **책임**이 부여된다.

이러한 사실에서 나오는 **중요한 개념**이 있다.

#### 여려 사람이 동일한 역할을 수행할 수 있다.

캐셔가 여러명일 수 있다. 그래도 상관없다.

요청하는 객체 입장에선 어떤 객체가 그 역할을 수행하던 상관없다. 

그 역할에 대한 책임만 다 해주면 된다.

#### 역할은 대체가능성을 의미한다.

* 캐셔는 대체될 수 있다. 
* 굳이 그 사람만이 캐셔를 해야 하는건 아니다. 대체가능하다.
* 특정 객체만이 그 역할을 수행할 수 있는게 아니다. 얼마든지 다른 객체로 대체가능하다.

#### 책임을 수행하는 방법은 자율적으로 선택할 수 있다.

* 요청을 받은 객체는 자신만의 방법으로 책임을 다할 수 있다.

* 어떤 객체A는 방법a를 쓸 수 있고, 어떤 객체B 방법b를 쓸 수 있다.

* 즉 동일한 요청에 대해서, 요청을 받은 객체에 따라 서로 다른 방식으로 동작할 수 있다는 것이다.

    ```note
    어디서 많이 들은 말이다. 다형성이다.
    
    그럼 추상클래스를 역할이라고 볼 수 있는가?  
    동일한 추상클래스A를 상속받은 클래스 가, 나, 다는 동일한 역할A를 가진다고 볼 수 있는가?  
    동일한 역할을 가졌기에, 그 역할에 명시된 어떠한 책임을 져야 한다는 건가?  
    다만, 동일한 역할일지라도, 각자 서로 다른 방법으로 그 책임을 다할 수 있다는 것인가?  
    그리고 이게 다형성이라는 말인가?  
    
    음... 맞는 것 같기는 하다만... 아닐 수도 있다. 좀 더 읽어봐야겠다.
    ```

#### 한 사람이 동시에 여러 역할을 수행할 수 있다.

* 예를 들면, 어떤 사람은 바리스타이면서, 한 가정의 엄마이거나 아빠일 수 있다.

* 두개 이상의 책임을 가질 수 있는 것이다.

  ```note
  근데, 하나의 객체가 동시에 여러 역할을 가질 수 있는걸까...?  
  인터페이스랑 연관이 있을까?  
  클래스는 두개 이상의 인터페이스를 구현할 수 있지 않은가?  
  근데 인터페이스로 역할을 표현할 수 있는가?  
  뭘까 대체...?  
  이건 그냥 하나의 객체가 두가지 역할로 쓰일 수 있다는 걸 말하고 싶었던걸까...?
  ```

### 역할, 책임, 협력

프로그램도 마찬가지다. 프로그램을 구성하고 있는 객체들은 저마다 역할이 있다. 그리고 이 역할에 따른 책임을 가진다. 각각의 객체들은 모든 일을 혼자서 다 할 수 없다. 자신이 할 수 없는 기능은 다른 객체에게 요청해야 한다. 요청받은 객체는 자신의 책임을 다하여야 하고, 그 결과를 요청한 객체에게 응답해줘야 한다. 프로그램또한 인간의 사회처럼 연쇄적인 요청과 응답을 통해 굴러가는 것이다.

근데 만약 자신의 책임을 다하지 못하는 객체가 있다면? 불분명한 책임을 맡은 객체가 있어서 어떤 요청을 정상적으로 처리해주지 못한다면? 그 순간 그 프로그램의 정상동작은 불분명해진다. 그래서 객체는 분명한 책임을 맡아야 한다는 것이다.

```note
그러면 하나의 수퍼객체가 프로그램의 모든 책임을 다 맡으면 안되는 걸까? 얘가 자신의 책임을 완벽하게 수행할 수 있다면, 굳이 여러 객체로 나누지 않아도 된다. 그렇지만 앞서 읽은 내용에 따르면, 작은 객체들이 작은 책임을 하나씩 맡고, 서로 협력해야 한다고 말한다. 왜? 꼭 그래야 하는 이유가 있을까?  
한편으론 그런 생각이 든다. 객체지향의 목적을 "객체들이 메세지를 주고 받으면서, 서로 협력해서 복잡한 문제를 해결하는 것" 이라고 생각한다면, 메세지를 주고받지도 않는, 협력하지도 않는 외로운 수퍼객체는 객체지향에 어긋나는 존재가 아닐까 라는 그런 생각이 든다. 따라서 어려운 문제를 작은 책임을 가진 여러 객체들의 협력으로 해결하고자 한건데, 수퍼객체를 만든다는건 복잡한 문제를 나눠서 풀지 않겠다는 말이라서 문제를 해결하는것이 많이 어려울 것 같다. 그래서 객체는 하나의 작은 책임을 지는게 좋다고 하는건지도 모르겠다.  
현실의 우리를 생각해보면, 개인의 힘에는 한계가 있다보니 한 사람이 프밍, 커피타기, 건축설계, 비행기 조종등 다양한 일을 전부 다 잘할 수 없다. 그치만 다들 프로그램도 쓰고 싶어하며, 맛있는 커피도 마시고, 튼튼한 집에서 살고 싶고, 비행기도 타고 싶어한다. 하지만 혼자 다 할 수 없으니, 사람들은 어떤 일을 할 줄 아는 사람에게 부탁해서 그 일을 완수한다. 그래서 우린 모든 역할을 다 맡을 필요가 없다. 다 잘할 줄 모르더라도 협력할 수 있는 능력만 있다면 개인으로서 불가능에 가까운 일을 해낼 수 있기 때문이다.
```

### 협력속에 사는 객체

앞서 생긴 의문에 대한 해답이 되는 장이다. 프로그램은 매우 복잡하다. 작은 기능이라고 해도, 너무 복잡하다. 이걸 하나의 객체에게 맡기기엔 그 책임이 너무 크다. 그치만 작은 객체들이 이 책임을 나눠서 진다면? 작은 책임만 졌으니까, 얘 하나 구현하는건 쉬워진다. 이런 애들을 나눠진 책임만큼 다 만들어 주고, 협력하게 시키면, 매우 복잡한 기능의 프로그램이라도 좀 더 쉽게 만들 수 있는 모양이다. 당장 하나의 객체에 모든 기능이 들어가 있다고 생각해보자. 당장 코드 수부터 몇만라인 이상이라고 생각해보자. 근데 여기서 어딘가에 문제가 생겼다면? 어디서부터 잘못된걸까? 어떤 함수부터 잘못한걸까? 디버거가 알려준 부분이 사실 진짜 문제의 근원이 아니였다면? 아마도 이런 문제 때문에 수퍼객체를 만들었을 때 복잡도가 크다고 하는 모양이다. 이런 문제를 피하기 위해 작은 책임을 지고있는 작은 객체들의 협력으로 복잡한 문제를 해결하고자 하는 것 같다.

그건 그렇고, 그래서 협력은 어떻게 해야 잘할 수 있는걸까? 책에 따르면, 자율성을 가져야 한다고 쓰여있다. 객체가 자율성을 가져야 한단다. 다른 객체에 의해 수동적으로 동작하기보다, 자기 스스로가 결정하고 판단해서 자신의 책임을 다해야 한단다.  객체가 책임을 다 한다는 말의 의미는, 다른 객체에 복종해서 시키는 일을 시키는대로 하는게 아니라, 요청한 일을 자신의 방법으로 처리하고 그 결과를 응답하는 것이다. 비슷한 말처럼 보이지만, 시키는 대로 한다는 것과, 자신의 방법으로 처리한다는 부분을 보면 다르게 보인다. 다른 객체의 상태등에 영향받지 않고, 자신의 방법대로 처리할 수 있는 자율성이 필요하다. 또한 요청한다고 반드시 응답해줘야 하는것도 아니다. 잘못된 요청을 한다면, 못한다고 말할 수 있어야 한다. 객체에겐 이런 자율성이 필요하다.

 객체는 자신의 상태를 알고 있어야 한다. 어떤 행동을 하려는데, 자신의 상태가 없다면 어떤 행동을 잘 할 수 있을까? 투수가 공을 던지려는데 어떻게 던지는지 모른다면? 던질 수 없다. 어떤 자세로 어떤 방식으로, 또 어떤 방향으로 얼마만큼의 힘으로 던져야 하는지 알아야 잘 던질 수 있다. 사실 던질 수 있다! 누가 옆에서 어떻게 던지는지 일일히 알려주면 된다. 근데 그건 더이상 자율적으로 던질 수 있는게 아니다. 그래서 객체가 자율적으로 어떤 행동을 하고자 한다면, 그 행동에 필요한 상태를 가져야 한다고 책에선 말한다.

```note
근데 이 내용은 잘 모르겠다. 행동에 필요한 상태가 프로그램에선 어떤걸까?
```

객체는 외부와 내부를 명확하게 나눠야 한다. 자신은 자신의 행동이 어떻게 동작하는지 다 알고 있어야 한다. 그래야 행동할 수 있으니까. 근데 다른 객체에 요청할 때, 그 객체가 어떻게 그 요청을 처리하는지 전부 알 필요가 있을까? 없다. 알 필요 없다. 다시 말해서, 객체의 외부에선 그 객체가 뭘 할 수 있는지만 관심이 있다. 어떻게 하는지는 별로 관심도 없고, 알 이유도 없다. 그래서 접근이 허가된 몇가지만 외부에 노출시키고, 그 동작은 감추는게 좋다. 이렇게 안하고, 외부에서 다 볼 수 있게 해버리면, 외부에선 많이 복잡해할 것이다. 그렇게 만들 필요가 없으니, 내부 동작원리는 숨기고, 협력에 필요한 접근수단만 노출시키는게 협력에 도움이 된다고 한다.

객체는 잘 협력하면서도 자신의 행동에 자율성을 가지는 존재라고 했다. 자율적으로 행동하기 위해, 객체는 그 행동을 하는데 필요한 상태를 가질 수 있어야 한다. 그래서 객체는 상태와 행동으로 구성된 존재이다.

예전엔 데이터와 프로세스를 업격하게 구분했는데, 지금은 이걸 객체로 묶어서 생각한다. 또한 이 객체는 자율성을 갖고 있어서 다른 객체에 영향받지 않고 자신의 책임을 다할 수 있다. 그래서 유지보수랑 재사용이 쉽다고 하는데, 왜?

```note
다른 객체에 영향받지 않고 자신의 책임을 다할 수 있는 자율적인 객체를 만들 수 있고, 얘들끼리 협력해서 복잡한 문제를 해결할 수 있는거랑 유지보수랑 재사용이랑 무슨 상관일까?  
어떤 객체가 자신의 책임을 다하는 방식에 수정이 발생히도, 다른 객체는 이걸 모른다. 애초에 보여주지도 않았으니까. 따라서 그 객체만 수정하면 된다. 다른 객체에겐 수정의 영향이 가지 않는다. 라는걸까?  
근데 왜 와닿지 않는걸까? 왜?
```

그건 그렇고, 얘들은 어떻게 협력할까? 협력하려면 소통해야하는데 어떻게 할까? 메세지를 주고 받으면서 한다. 보내는 애가 송신자(Sender) 받는애가 수신자(Receiver)이다. 메세지를 수신한 객체는 자신이 이 메세지를 이해할 수 있는지 보고, 할 수 있으면 자신의 메서드로 메세지를 자신만의 방법으로 처리한다.

객체지향 언어에서는 메세지를 수신한 객체가 실행시간에 메서드를 선택할 수 있다고 책에 쓰여있다. 그리고 이게 다른 언어와 비교되는 특성이라고 한다.

메세지와 메서드를 분리하는 것은 객체들이 협력하는데 있어서 자율성을 높여준다고 한다. 커피를 만들어달라고 요청서를 넣으면, 바리스타가 커피를 자신만의 방법으로 만들어 준다. 어떻게 만들던 그건 바리스타 마음이다. 여기서 요청서가 메세지가 되고 커피 만드는 방법이 메서드가 된다. 다시말해 외부의 요청과 이 요청을 수행하는 구체적인 방법을 분리시켜서 객체가 자신만의 방법으로 책임을 다할 수 있도록 한다는게 핵심이라고 한다. 이게 캡슐화랑 큰 관련이 있다고는 하는데, 잘 모르겠다. 아무래도 객체가 다른 객체의 영향을 받지않고 자율적으로 행동하는게 어떤 이점이 있는지 잘 모르겠어서 메세지와 메서드의 분리가 왜 좋은지 이해하지 못하는 것 같다.

### 객체지향의 본질

* 객체지향은 객체를 이용해서 시스템을 분할한다. 객체들은 서로 공동체를 형성하여 문제를 해결한다.
* 각각의 객체들은 공동체속에서 저마다 역할을 가진다. 그리고 그 역할을 다하기 위해서 책임을 완수한다.
* 객체는 상태와 행동으로 구성된다. 
* 객체는 서로 메세지를 주고받으면서 협력한다. 어떤 일을 해야 한다면, 그 일을 할 수 있는 객체에게 메세지를 보내서 요청하고, 그걸 받은 객체는 자기만의 방식으로 그 요청을 처리하고 결과를 응답해준다. 이때, 객체는 자율적인 존재이기 때문에, 다른 객체에 의존하지 않고 자신의 책임을 다한다.
* 객체는 요청을 처리하는데 적합한 메서드를 자율적으로 선택할 수 있다.

### 객체를 지향하라

보통 객체지향에 대해서 이야기하면, 클래스에 대해 이야기한다. UML에서 대표적인 다이어그램을 꼽으라고 하면 클래스 다이어그램을 꼽는다. 또, OOP언어에 대해 이야기하면 클래스를 정의하는 방법과 상속에 초점을 맞춘다. 객체지향 분석설계의 목적은 훌륭한 클래스를 식별하는 것일까?

물론 클래스도 중요한 구성요소이지만, 중심개념이라고 하기는 어렵다.JS같은 경우엔 클래스가 없고, 오직 객체만이 존재한다.프로토타입 언어는 상속역시 클래스가 아닌 객체간의 위임 매커니즘을 기반으로 한단다. 

지나치게 클래스를 강조하면 객체의 캡슐화를 저해하고 클래스를 서로 강결합시킨단다. 애플리케이션을 클래스로 구성된 일종의 설계도로 보기 때문에 이렇게 된다고 한다. 그래서 이렇게 하면 안되고, 애플리케이션을 클래스를 이용한 설계도 같은게 아닌, 객체들의 공동체로 보아야 한다고 책에선 설명한다.

```note
사실 이 부분은 정말 와닿지 않는다. 애플리케이션을 클래스로 구성된 설계도로 본다는건 어떤걸 말하는걸까?
그리고 왜 애플리케이션을 설계도로 생각하면 캡슐화가 저해되고 강결합이 되는걸까? 
일단 캡슐화가 저해되고 강결합이 된다는건 객체들이 자율성을 갖지 못하고 서로가 서로를 너무 의존하기 때문에 그렇다고 생각한다. 근데 설계도의 관점으로 애플리케이션을 바라보는거랑 의존이랑 무슨 관계일까?
아직 잘 모르겠다.
```

저자는 훌륭한 객체지향 설계자가 되기 위해선 코드를 담는 클래스의 관점에서 벗어나서, 공동체를 이루고, 서로 협력해가면서 큰 문제를 해결하는 작은 객체들의 관점으로 사고를 전환하라고 한다. 객체들이 메세지를 주고 받으면서 협력한다는 개념이 중요하다고 한다. 클래스는 그저 객체들의 협력관계를 소스코드로 표현하는 도구일 뿐이라고 설명한다.

따라서 우리가 해야 할 일은, 객체들이 잘 협력하며 공동체를 이룰 수 있게 설계하는 것이다. 이를 위해서, 객체들에게 올바른 역할을 부여해줘서 객체들이 자신의 책임을 잘 해낼 수 있게 만들어주어야 할 것 같다. 

그러니, 객체들이 올바른 역할을 맡고 자신의 책임을 잘 해내서 서로 협력할 수 있는, 좋은 공동체를 이룰 수 있도록 많이 공부해야겠다.