---
sort: 5
title: 알고리즘 기초 1/2 수학 - 3 소수와 에라토스테네스의 체
tags: [ 알고리즘, 백준 ]
---

## CodePlus 알고리즘 기초 1/2 수학 1-1

### 소수(PrimeNumber)

약수가 1과 자기자신밖에 없는 수를 말한다.

어떤 수 N이 소수인지 판별하려면 어떻게 해야 할까?

또, 범위 안의 모든 소수를 찾으려면 어떻게 해야 할까?

### 어떤 수 N이 소수인지 판별하기

N이 2보다 작다면, 소수가 아니다.

N이 소수가 아니라면,` A * B = N`을 만족하는 A랑 B가 있다. 그러면` A는 √N보다 작고`, `B는 √N 보다 클 수밖에` 없다. 근데 둘 다 √N보다 작으면, `A*B < N이기 때문에 모순`이다. 두 수가 √N보다 크면 A * B > N이 되버려서 이것도 모순이다. 그래서 항상 `A는 √N보다 작고`, `B는 √N 보다 크다`. 그러니까 2부터 √N까지만 약수를 찾으면 된다. 이 안에 없으면 A, B 둘 다 √N 보다 크다는 소리고, 아까 이건 모순이라고 했으니까 √N 이후로는 검사할 필요 없다.

그래서 `O(√N)`이다.

근데 `√N`의 경우 실수가 될 수 있는데, 실수는 근사값으로 계산하기 때문에 오차가 생길 수 있다. 물론 정수형으로 형변환하면 괜찮기는 한데, 그냥 `i * i <= N`이런 식으로 하는편이 좋다.

### 어떤 수 N이하의 소수를 구하는 알고리즘( 에라토스테네스의 체 )

##### `√n`까지 모듈로연산하는 케이스의 한계

위의 알고리즘으로 1부터 N까지 소수판별을 하면, `O(N√N)`이 된다. N이 백만이라고 치면 백만 * 천으로 10억이 나오니 너무 오래걸린다.

이걸 해결하기 위해서 `에라토스테네스의 체`를 쓸 수 있다.

##### 에라토스테네스의 체

>  `2`부터 `√n`까지, 각각의 수 i의 배수에 해당하는 수를 테이블에서 싹 날려버린다. 남은 수는 소수뿐이다.
>
> 

##### 예시

1부터 100까지의 소수를 구한다. 그러면 `√100인 10까지` 아래와 같은 일을 반복한다.

i의 배수를 다 지운다. 그래서 2의 배수를 다 지운다. 남은 수 중에서 3의 배수도 다 지운다 4는 2의 배수로 이미 지워졌다. 5의 배수를 다 지운다.  7의 배수까지 지우면, 모든 소수를 구했다고 볼 수 있다. 아까 A * B = N을 생각해보면, √N보다 작거나 같은 모든 A에 대해 검사를 한 셈이니, 테이블에 남은 수는 전부 소수임이 보장된다. 아 그리고, 어떤 소수의 제곱 이전의 수는 이미 다 제거된 상태이다. 가령 3 * 2, 3 * 3을 생각해보자. 이미 2에서 2의 배수인 모든걸 다 지웠다. 그리고 3 * 2이지 않은가, 얜 2의 배수인거니까 이미 지워졌다. 그래서 제곱부터 지워나가면 된다.

시간복잡도는 `O(NlglgN)`이다. 

##### 어려웠던 점

이걸 프로그래밍으로 써먹는게 좀 까다로웠다. 어떤 수 N 이하의 소수를 찾는다면, 우선 테이블부터 만들어야 한다. 0부터 N+1까지의 테이블을 만든다. 2부터 소수인데, 그렇다고 배열의 0번째를 2로 취급하면 까다로우니, 그냥 앞의 0, 1은 낭비하게 내버려둔다. N+1까지 크기를 잡은 이유는, N이하의 소수를 찾는거라 그렇다. isDeleted[N]을 했을 때, 얘가 지워졌는지 확인하려면 N + 1만큼의 공간을 할당하는게 좋다. 테이블을 만들었으면, i = 0 -> i < N; i++로 루프를 돈다. 이때 isDeleted[i]가 false라면, 지워지지 않았다는 소리니, 얘는 소수다. 시작조건이 2였으니, 2는 무조건 소수로 취급된다. 이렇게 소수로 취급된 요소는 따로 보관한다.

그런 다음, 에라토스테네스의 체에서 배운대로, 소수의 배수를 전부 날려야 한다. j = i + i -> j <= N ; j += i로 루프를 돌면서 check[j]에 true를 넣으면 된다. 현재 루프에서 찾은 소수 i의 배수는 += i이다. 구구단을 생각해보면 간단할 것 같다. 2 * 2 = 4, 2 * 3 = 6, 2 * 4 = 8 이런식이니까, 인덱스가 배수로 뛰고 싶으면, 자신만큼 계속 더해주면 된다. 그러면 *2, *3, *4, *5 ... 해나가는거랑 같기 때문이다. 여하튼 스탭은 그렇다치고, 어떤 소수의 제곱부터 지워나가랬는데, i + i부터 지워나가고 있다. i * i로 하게 되면, 변수의 표현 범위를 쉽게 벗어날 수 있어서 이상한 값이 들어가기 쉽다. 그래서 그냥 i + i부터 하는 것.

#### 에라토스테네스의 체 : 소스코드

```java
public class p17103 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader( System.in ));
        int n = Integer.parseInt(br.readLine());
//에라토스테네스의 체 _________________________________________________________
        boolean[] check = new boolean[n+1];//초기값이 false인걸 이용한다.
        for (int i = 2; i <= n; i++) {//2부터 시작, n까지 포함해서 구한다.
            if(!check[i]){
                int from = i + i;//i는 이미 소수인걸 안다. 
                //원래는 i*i부터인데, 이러면 오버플로우가 나서 원하는 값이 안나올 수 있다.
                for (int j = from; j <= n; j+=i) {//n을 포함한 범위까지, i의 배수를 지운다.
                    check[j] = true;//check에서 true인건 소수가 아니라는 뜻이다.
                }
            }
        }
//_________________________________________________________ 에라토스테네스의 체

        for (int i = 2; i <= n; i++) {
            if(!check[i])//소수만 출력한다
                System.out.print(i + " ");
        }

        br.close();
    }
}
```

