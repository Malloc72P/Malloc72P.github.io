---
sort: -12
title: TIL-12, 열두번째.
tags: [ TIL, OOP, CodePlus, 백준 ]
---

## 오늘은 어땠을까

컨디션 : 피곤하고 졸림. 잠을 잘 못잤음.



***

#### 오늘 할 일

- [ ] 리액티브 선언문 읽어보기

- [ ] 함수형 프로그래밍이 뭔지 간단하게 알아보기

- [ ] 함수형 프로그래밍을 적용해서 미션1 풀기

- [ ] 고차함수가 뭔지 간단하게 알아보고 map, reduce, filter를 써서 미션 2 풀기

- [ ] 코테문제 풀기

- [ ] 남은시간은 객체지향에 대해 계속 공부하자.

  객체지향의 사실과 오해라는 책을 읽으면서 내 방식대로 한번 구조화해보자.

  그런 다음 루카스의 학습정리를 보고 글로 정리해보자. 

  오늘 다 하자는게 아니다. 이건 좀 긴 시간을 들여야 할 것 같다.

  * 업캐스팅, 다운캐스팅
  * 간접참조 및 객체지향 5대원칙(단일책임의 원칙 등...)



## 오늘 배운 내용  
#### 루카스 함수형 프로그래밍

람다계산, 알론조 처치가 고안한 람다 카큘러스를 기반으로 함. 

위키에 잘 정리되어있으니 한번 볼 것

함수가 일등 시민이어야 한다?

일등시민? 일급 객체??? 함수 그 자체가 객체인 것 처럼 사용할 수 있다?

함수도 리터럴로 다룰 수 있다? 리터럴?

매개변수로 함수를 넣고 싶은 순간 있어도 못해. 함수는 함수라서

자바 7 이전엔 클래스 하나 만들고, 그 클래스는 멤버로 변수가 아니라 메서드 한개를 멤버로 가져

그리고 그 클래스의 인스턴스를 만들어서 걔를 넘겨주는 것. 이렇게 복잡하게 했는데, 자바8부터는 람다란게 나와서 함수형 프로그래밍이 가능해짐

사이드이펙트가 발생하지 않는다. 퓨어 펑션의 경우, 입력이 같으면 언제나 같은 결과가 나옴

함수라는게 뭔가 다른 상태에 의존하지 않는다

퓨어펑션이 아닌 경우가 많다? 함수형 프밍의 함수는 수학의 함수와 완전 비슷하다?

고차함수? 미션은 두가지? 기존에 있는 스파게티코드에 가까운 걸 함수형 표현으로 잘 리팩토링하는게 첫 미션

두번째는 만들어진걸 고차함수를 이용해서 실행하는 것

함수를 추상화하면 차원이 높아진다고??? 응???

리턴으로 함수를 쓰면 고차함수의 일종??? 매개변수나 리턴을 함수로 써?? 함수의 중첩을 말하는 것?????

자바는 스트림 api. 맵 리듀스, 필터 같은걸로 함수형 프밍의 맛을 볼 수 있다?

포문으로 처리하던걸 함수형 프밍으로 처리가능?????

첫 미션은 그냥 여깄는 코드를 함수형 프밍으로 바꾸는 것?

두번째에 첫 미션의 힌트가 있다. 두번째는 첫 미션을 가지고 고차함수(맵, 필터, 리듀스)를 활용해서 구현해봐라.

익숙하지 않아? 그럼 간단한 튜토리얼이나 검색을 통해 맛을 봐라.

객체지향은 유지보수와 가독성이 굉장히 큰 축?

함수형 프밍은 역시 마찬가지. 유지보수 + 가독성 + 멀티코어, 분산시스템에서 사이드 이펙트를 없애서 병렬프밍을 용이하게 하는게 목적? 여튼 리엑티브 선언문도 찾아보는게 좋겠죠 여기서 끝내겠음.



***

## 코딩일일결산
#### 내일의 나에게 보내는 전달사항

#### GOOD

* 

#### BAD

* 



#### 리액티브 선언문

예전보다 애플리케이션에 대한 요구사항이 높아졌다. 더 빨리 응답시간이 요구되고, 처리해야 하는 데이터량도 많아졌다. 응답이 잘 되고, 탄력적이며 유연하고 메시지 기반으로 동작하는 시스템을 리액티브 시스템이라고 한다. 리액티브 시스템으로 구축하면 유연하고 느슨한 결합을 가지면서, 확장성이 높다. 덕분에 요구사항 변경에 대응하기 쉬워진다. 또한 장애에 대한 강한 내성이 있어서 간결한 방식으로 해결할 수 있다.

##### 응답성

신뢰할 수 있는 상한선을 설정하고, 일관된 서비스 품질을 제공한다

##### 탄력성

시스템이 장애에 직면해도 응답성을 유지한다면, 탄력성이 있다고 부른다. 이게 없으면 장애발생시 응답성을 잃어버린다. 이건 복제, 봉쇄, 격리, 위임에 의해 실현된다는데, 아직 이게 뭔지 잘 모르겠어서, 어떻게 탄력성을 가진다는건지는 잘 모르겠다. 일단 알 수 있는건, 장애가 발생해도 응답성을 잃지 않는, 탄력성이 있는 시스템을 만들어야 한다는 것이다.

##### 유연성

시스템이 작업량이  변화해도 응답성을 유지한다. 변화에 잘 대응해서 병목현상이 존재하지 않도록 설계하고, 부하를 분산시킨다

##### 메시지 구동

비동기 메시지 전달에 의존한다. 덕분에 구성요소 사이에서 느슨한 결합, 격리, 위치 투명성을 보장하는 경계를 형성한다...? 이 경계는 장애를 메시지로 지정하는 수단을 제공한다는데, 뭐지...? 여튼 메시지 큐를 생성하고, 이걸 모니터링하면서 배압이란걸 적용해서 유연성을 부여하고 부하관리나 흐름제어가 가능하게 한단다. 아. 근데 쉽게 이해하긴 어려운 내용들이다. 일단 여기까지만 정리하고, 나중에 더 내공이 쌓이면 그때 다시 보자. 

그나저나 이게 왜 이해하기 어려운가 라고 물어본다면, 그건 내가 결합도가 높아지면 왜 문제가 생기는지를 잘 모른다거나, 위치투명성이라는 말의 의미를 이해하지 못하는 등, 기초지식이 얕기 때문에, 리액티브 선언문을 이해하기 어렵다고 말한 것이다. 그래서 더 공부해야 이해할 것 같다고 말한 것이다.

일단은 리액티브 선언문이라는게 더 빠른 응답시간을 일관성있게 보장하며, 부하를 유연하게 분산시키는데다가 요구사항 변경에 대응하기 쉽고 장애에 대처하기 좋은 아주 멋진 시스템이란건 알겠다. 문제는 왜 그런건지를 잘 이해하지 못하는게 문제지만. 근데 서버에 대해 좀 더 지식이 쌓이면 이해할 수 있지 않을까?



##### FunctionalInterface는 또 뭘까?

람다표현식을 쓰려면, @FunctionalInterface어노테이션을 써야 한다. 아니라면, 컴파일타임에러가 발생한다??? 그 외에도 사용자가 봤을 때 FunctionalInterface이면 람다표현식을 쓸 수 있구나! 하고 알 수 있다.

Runnable인터페이스 타입으로 람다표현식을 넘기거나 받을 수 있다. Runnable인터페이스가 @FunctionalInterface로 선언되어 있어서 그렇다.

##### FreeVariable과 Final.

예전엔 FreeVariable은 반드시 final로 선언해야 했다. 안그러면 컴파일 에러가 발생했다. 근데 java8부터는 final이 아니어도 된다. 이야 그럼 final아니니까 값을 변경할 수 있겠네? 하고 값을 변경하려고 들면, 못한다. 사실상 final인데 굳이 선언에 final을 붙일 필요가 없는 것일 뿐이다. 이걸 **Effectively Final**이라고 부른다. 단지 편의를 위해서 final을 안적어도 된다 라고 만든 것 뿐이다. final처럼 써야 문제가 생기지 않는다.

final을 안붙인 상태에서 람다표현식에 FreeVariable을 넘기는데, 이 변수의 값을 수정한다면? 에러가 발생한다. 람다표현식에서 변수를 쓰려면, final이거나 Effectively Final이어야 하는데, 지금 이걸 어겨서 그렇다. 람다표현식을 넘기기 전에 값을 바꾸던, 넘기고 난 다음 바꾸던 에러는 발생한다.

##### 그래서 왜 FreeVariable은 Final이거나 Effectively Final이어야 하는걸까? 

멀티스레드에서 RaceCondition이 발생할 수 있기 때문에 저렇게 만들어 놨다고 한다. 만약 자유변수가 Final이 아니라고 가정해보자. 싱글스레드라면 한 순간에 실행될 수 있는 실행흐름이 애초에 하나니까 람다표현식으로 넘긴 함수가 실행되고 있는데, 건드리지도 않은 FreeVariable값이 갑자기 바뀐다거나 하는 문제거 없을 것이다.

근데 이제 멀티스레드 환경이라면, 한 순간에 실행될 수 있는 실행흐름이 여러개일 수 있다. T1이 FreeVariable을 읽으려는데 그 전에 T2가 FreeVariable값을 바꿔버렸다면? T1은 람다표현식을 넘겼을 때의 FreeVariable 값을 가지고 계산해야 하는데, 도중에 누가 값을 바꿔버린다면, 의도된 계산결과가 나오지 않을 것이다. 그래서 final로만 FreeVariable을 쓸 수 있게 만들어 놨다고 한다.

##### 변수를 캡쳐한걸까 아니면 변수의 값을 캡쳐한걸까?

변수를 캡쳐한게 아니라 값을 캡쳐한거라고 한다. 람다표현식에 해당하는 인스턴스가 런타임에 생성되면, 이때 FreeVariable에 대한 정보를 가지고 있는게 아닌, 그 변수의 값을 캡쳐해간다. 그래서 이 값이 바뀌면 안된다.



### 함수형 프로그래밍과 람다 계산

#### 함수형 프로그래밍이 뭘까?

##### 함수형 프로그래밍의 정의

> **함수형 프로그래밍**(functional programming)은 자료 처리를 [수학적 함수](https://ko.wikipedia.org/wiki/함수)의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 [프로그래밍 패러다임](https://ko.wikipedia.org/wiki/프로그래밍_패러다임)의 하나이다. [명령형 프로그래밍](https://ko.wikipedia.org/wiki/명령형_프로그래밍)에서는 상태를 바꾸는 것을 강조하는 것과는 달리, 함수형 프로그래밍은 함수의 응용을 강조한다. 프로그래밍이 [문](https://ko.wikipedia.org/wiki/문_(프로그래밍))이 아닌 식이나 선언으로 수행되는 [선언형 프로그래밍](https://ko.wikipedia.org/wiki/선언형_프로그래밍) 패러다임을 따르고 있다. 
>
> *by 위키백과 [함수형 프로그래밍](https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)*

일단은 **자료처리를 수학적 함수의 계산으로 취급**하고, **상태와 가변데이터를 멀리하겠다**는 말부터 이해해야 할 것 같다. 

```note
좀 더 정리해보니, 상태와 가변데이터를 멀리하겠다는 말의 의미를 조금 알 것 같다.
함수형 프로그래밍의 함수는 순수함수이다. 따라서 외부의 객체나 상태에 영향받지 않는다.
그 덕분에 부작용(Side Effect)이 없다.
이게 바로 상태와 가변데이터를 멀리하고 있는게 아닐까?
또한 순수함수는 수학적 함수와 그 성질이 비슷하다고 할 수 있다. 같은 입력이 주어지면 항상 같은 출력이 나오기 때문이다. 함수형 프로그래밍을 하겠다는 말은, "단순히 함수를 많이 쓰겠어요." 라고 하는게 아닌, 수학적 함수를 이용해서 프로그래밍 하겠다는 말이 아닐까? 
```

##### 함수형 프로그래밍의 함수는 순수함수이고, 순수함수는 참조 투명성이 있어야한다.

>  **Referential transparency** and **referential opacity** are properties of parts of [computer programs](https://en.wikipedia.org/wiki/Computer_program). An [expression](https://en.wikipedia.org/wiki/Expression_(programming)) is called referentially transparent if it can be [replaced](https://en.wikipedia.org/wiki/Rewriting) with its corresponding value (and vice-versa) without changing the program's behavior.[[1\]](https://en.wikipedia.org/wiki/Referential_transparency#cite_note-1) This requires that the expression be [pure](https://en.wikipedia.org/wiki/Pure_function), that is to say the expression value must be the same for the same inputs and its evaluation must have no [side effects](https://en.wikipedia.org/wiki/Side_effect_(computer_science)). An expression that is not referentially transparent is called referentially opaque.
>
>  *by 위키백과 함수형 프로그래밍 두번째 문단*
>
>  [추가로 참조한 링크](https://velog.io/@keum0821/FP-%EC%B0%B8%EC%A1%B0-%ED%88%AC%EB%AA%85%EC%84%B1Referential-Transparency)

어떤 표현식(함수)이 있을 때, 이 표현식을, 이 표현식의 결과로 대체해도 프로그램에 아무런 지장이 없다면, 참조에 투명하다 라고 표현한다.

예를 들면, f(x) = x + 5라는 표현식이 있다고 치자. 입력이 1이라고 할 때, 이 표현식의 결과는 6이다.

그럼 이제 f(1)이라는 표현식을 6으로 대체할 수 있는가? 1 + 5 = 6이니까 대체할 수 있다.

따라서, 참조투명성이 있는 함수는 입력이 같다면, 항상 같은 출력이 나와야 한다. 어떤 시점에선 입력0에 출력이 1이 나오고, 어떤 시점에선 입력 0에 출력이 2가 나온다면, 이 함수는 수학적 함수가 아니다. 

따라서 함수형 프로그래밍에서의 함수는 입력된 인수에만 의존한다. 그래서 결과를 예측하기 쉽다.

또한 참조 투명성이 있는 함수는 어떤 입력을 가지고 어떤 출력을 내놓는 것 외엔 추가적인 작업을 하지 않는다. 이러한 추가적인 작업으로 인해 부수효과(Side Effect)가 발생하지 않도록 한다.

##### 함수형 프로그래밍을 위해 쓰이는 람다 계산

> [알론조 처치](https://ko.wikipedia.org/wiki/알론조_처치)가 1930년대에 개발한 [람다 대수](https://ko.wikipedia.org/wiki/람다_대수)는 함수에 대한 이론적 기반을 세웠다. 이것은 프로그래밍 언어가 아니라 수학적 추상화였지만, 이것은 함수형 프로그래밍의 근간을 이루었다.
>
> *by 위키백과 함수형 프로그래밍 - 역사*
>
> 
>
> 함수형 프로그래밍은 1930년대에 계산가능성, 결정문제, 함수정의, 함수응용과 재귀를 연구하기 위해 개발된 형식체계인 [람다 대수](https://ko.wikipedia.org/wiki/람다_대수)에 근간을 두고 있다. 다수의 함수형 [프로그래밍 언어](https://ko.wikipedia.org/wiki/프로그래밍_언어)들은 람다 연산을 발전시킨 것으로 볼 수 있다.
>
> *by 위키백과 함수형 프로그래밍 - 첫번째 문단*

아직은 람다 계산이 뭔지 잘 모르겠지만, 일단 이게 함수에 대한 이론적 기반을 세웠다고 한다. 근데 어떤 기반을 세운걸까? 이게 뭐길래? 뭘 했길래? 여튼간에 다수의 함수형 프로그래밍 언어는 람다연산을 발전시킨 것으로 볼 수 있다고 한다. 일단 람다가 뭔지부터 알아봐야겠다.

### 람다 계산(Lambda Calculus)

> [함수](https://ko.wikipedia.org/wiki/함수)는 [컴퓨터 과학](https://ko.wikipedia.org/wiki/컴퓨터_과학)과 [수학](https://ko.wikipedia.org/wiki/수학)의 기초를 이루는 개념이다. 람다 대수는 함수를 단순하게 표현할 수 있도록 하여 '함수의 계산'이라는 개념을 더 깊이 이해할 수 있게 돕는다.
>
> *by 위키백과 [람다 대수](https://ko.wikipedia.org/wiki/%EB%9E%8C%EB%8B%A4_%EB%8C%80%EC%88%98) 도입 - 함수의 표현*

#### 람다 계산은 다음과 같은 특징이 있다

* 람다 계산은 **함수를 단순하게 표현할 수 있도록 해준다.** 

* 람다 계산은 **반드시 이름을 가질 필요가 없다**.

  ![{\displaystyle (x,y)\mapsto x\times x+y\times y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/cb7ae3435d6d9913ac8ecce1db0dbb8a96784efe)이런 식으로 쓸 수 있다.

* **입력변수의 이름도 필요 없다.**

  ![{\displaystyle (x,y)\mapsto x\times x+y\times y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/cb7ae3435d6d9913ac8ecce1db0dbb8a96784efe)이것과 ![{\displaystyle (u,v)\mapsto u\times u+v\times v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1b077445481c061950e6279012dd16eab70031a0)이 람다식은 변수의 이름은 다르지만, 같은 함수이다.

* **두개 이상의 입력을 받는 함수는 하나의 입력을 받아 또다른 함수를 출력하는 함수로 다시 쓸 수 있다.** 

  요 표현이 좀 이해가 잘 안가는데, 우선 ![{\displaystyle (x,y)\mapsto x\times x+y\times y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/cb7ae3435d6d9913ac8ecce1db0dbb8a96784efe)이런 함수를 ![{\displaystyle x\mapsto (y\mapsto x\times x+y\times y)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/680dc9e0a184c55cddda96209dd662e046350b0b)이런 형태로 다시 쓸 수 있단다. 

  그럼 이 함수를 s라고 했을 때, s(x, y)는 

  ![{\displaystyle (x\mapsto (y\mapsto x\times x+y\times y))(5)(2)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6adb05233edc5dceb3514c798e2dcdca1f3e3810) 여기서 x -> 랑 y -> 를 단일입력함수라고 부르는 모양이다. 

  단일입력함수를 두번 적용하게 된다.

  ![{\displaystyle =(y\mapsto 5\times 5+y\times y)(2)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/bcccc2a0da907bee310607459d6140e075bf3fb6) 

  ![{\displaystyle =5\times 5+2\times 2}](https://wikimedia.org/api/rest_v1/media/math/render/svg/478f541281ad581779c08198d3ce706443b4bcf0) 

  아, 그러니까 원래는 두개의 입력을 받는 함수였는데, 하나의 입력을 받는 함수로 고쳐쓰는게 된다는 걸 표현하고 싶었던 예제인거구나. 그러니까 람다함수의 결과를 다른 람다함수의 입력으로 넣을 수 있는 모양이다.

#### 핵심개념 : 람다 계산으로 표현하기

* ![{\displaystyle \lambda x.t}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6c340da553f36c8832a4a6aff7d235dd2acb760a) 단일입력 x를 받아 표현 t로 표현하는 익명함수를 이렇게 표현한다.

  **λx. x^2 + 2**는  **f(x) = x^2 + 2**를 **람다 계산**으로 **추상화**한 것이다. 

  람다 추상화를 통해 함수를 정의한다는 건, 함수 f(x)를 람다식으로 정의만 하고, 호출하진 않는 것을 의미한다.

* **자유변수**

  [출처 : Introduction to the lambda calculus](http://www.cs.columbia.edu/~aho/cs4115/Lectures/15-04-13.html)

  람다 추상화를 통해 표현에 묶이지 않은 변수를 말한다. 여기서 말하는 표현은 왼쪽의 람다표현을 말한다.

  **λx. x**의 변수 x는 **λx**표현에 묶여있다. 그래서 x는 자유변수가 아니다

  **λx. xy**의 반면 y는 표현에 묶여있지 않다. 그래서 y는 자유변수이다.

```note
앞에서 다수의 함수형 프로그래밍 언어는 람다계산을 발전시킨 것으로 볼 수 있다는 말이 나왔다.
왜 위키에 그렇게 적혀있나 궁금했는데, 람다계산을 쓰면 함수를 단순하게 표현할 수 있어서 그런게 아닐까?
그래서 함수형 언어에서 람다계산으로 함수를 표현하는게 아닐까 라는 생각이 들었다.
***
근데 추가로 더 정리해보니, 자바에서 말하는 자유변수개념이 위의 자유변수에 대한 설명이랑 무슨 관계가 있는지 연결해서 이해하기가 어렵다. 일단은 [영상](https://www.youtube.com/watch?v=pjtk7vvryio&feature=youtu.be)에서 본 내용으로 이해하도록 하자.
```

### 