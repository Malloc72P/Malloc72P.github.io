---
sort: 1
title: 알고리즘 기초 1/2 소개 - 시간복잡도
tags: [ 알고리즘, 백준 ]
---

## CodePlus 알고리즘 기초 1/2 시간복잡도

### 시간복잡도

시간복잡도란 알고리즘 수행에 걸리는 시간을 예측하는 것을 말한다. 여러 표현법이 있는데, Big-o표기법이 대표적이다.

#### Big-O 표기법

성능의 상한, 중간, 하한을 표현하는 표기법이다

##### 빅오

성능의 상한을 표현한다. 알고리즘을 수행하는데 걸린 시간이 적어도 O(?)보다는 낮다는 것을 의미한다. 그래서 알고리즘이 최악일 때를 표현할 때 쓴다.

##### 빅세타

성능의 중간을 표현한다. 알고리즘이 보통 이정도 걸린다고 표현할때 쓴다.

##### 빅오메가

성능의 하한을 표현한다. 적어도 이것보다는 많이 걸린다는걸 의미한다. 그래서 알고리즘이 최선의 상황일 때를 표현할 때 쓴다.

#### 시간복잡도가 필요한 상황

어떤 프로그램을 만드려는데 성능을 고려해야 하는 경우, 시간복잡도를 따져가면서 짜는게 좋다. 내가 짠 알고리즘의 성능을 시간복잡도로 표현해보면 얼마나 걸릴지 대략적으로 예측할 수 있다. 만약 O(N^N) 이라면, 안짜는게 좋을 것 같다.

코테문제도 마찬가지이다. 특히 얘가 제일 문제이다. 특정 범위의 소수를 전부 구하는 문제인데 1초안에 풀라고 시키면? 근데 내 알고리즘의 시간복잡도가 O(n^2)라면? 근데 입력의 범위가 1 <= N <= 1,000,000이라면? 과연 풀릴까? 근데 시간복잡도를 알아도 예측하기가 쉽지 않다.

대충 입력이 1억개고 O(N)이면 1초가 걸린다고 생각하자. 그럼 O(nlgn)이면, n이 500만쯤 되어야 1억에 가까운 수가 된다. O(n^2)이면? n이 1만정도만 되어도 가볍게 1초가 넘어간다. 그래서 위의 경우, 절대 풀리지 않는다. 시간초과하니까.

입력범위가 저런데 1 -> n까지 도는 2중루프를 도는게 현명할까? 아닐 것이다. 그렇게 푸는게 아니라는걸 알 수 있는 좋은 단서가 바로 이것이다.

### 그 외의 팁

* BufferedReader를 쓰면 성능을 조금 올릴 수 있다.
* 여러줄의 문자열을 출력해야 한다면, StringBuilder를 쓰는게 매우매우 좋을것이다. 다만, sb.append(String.format("%d + %d = %d\n",a,b,a+b))이런식으로 쓰면 성능향상이 거의 없다. 이러지말고, sb.append(a).append(" + ").append(b).append(" = ").append(a+b).append("\n")이렇게 해야한다. 성능차이가 정말정말 많이 난다.