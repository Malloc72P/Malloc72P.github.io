---
sort: -12
title: TIL-12, 열두번째.
tags: [ TIL, OOP, CodePlus, 백준 ]
---

## 오늘은 어땠을까

컨디션 : 피곤하고 졸림. 잠을 잘 못잤음.



***

#### 오늘 할 일

- [ ] 리액티브 선언문 읽어보기

- [ ] 함수형 프로그래밍이 뭔지 간단하게 알아보기

- [ ] 함수형 프로그래밍을 적용해서 미션1 풀기

- [ ] 고차함수가 뭔지 간단하게 알아보고 map, reduce, filter를 써서 미션 2 풀기

- [ ] 코테문제 풀기

- [ ] 남은시간은 객체지향에 대해 계속 공부하자.

  객체지향의 사실과 오해라는 책을 읽으면서 내 방식대로 한번 구조화해보자.

  그런 다음 루카스의 학습정리를 보고 글로 정리해보자. 

  오늘 다 하자는게 아니다. 이건 좀 긴 시간을 들여야 할 것 같다.

  * 업캐스팅, 다운캐스팅
  * 간접참조 및 객체지향 5대원칙(단일책임의 원칙 등...)



## 오늘 배운 내용  
#### 루카스 함수형 프로그래밍

람다계산, 알론조 처치가 고안한 람다 카큘러스를 기반으로 함. 

위키에 잘 정리되어있으니 한번 볼 것

함수가 일등 시민이어야 한다?

일등시민? 일급 객체??? 함수 그 자체가 객체인 것 처럼 사용할 수 있다?

함수도 리터럴로 다룰 수 있다? 리터럴?

매개변수로 함수를 넣고 싶은 순간 있어도 못해. 함수는 함수라서

자바 7 이전엔 클래스 하나 만들고, 그 클래스는 멤버로 변수가 아니라 메서드 한개를 멤버로 가져

그리고 그 클래스의 인스턴스를 만들어서 걔를 넘겨주는 것. 이렇게 복잡하게 했는데, 자바8부터는 람다란게 나와서 함수형 프로그래밍이 가능해짐

사이드이펙트가 발생하지 않는다. 퓨어 펑션의 경우, 입력이 같으면 언제나 같은 결과가 나옴

함수라는게 뭔가 다른 상태에 의존하지 않는다

퓨어펑션이 아닌 경우가 많다? 함수형 프밍의 함수는 수학의 함수와 완전 비슷하다?

고차함수? 미션은 두가지? 기존에 있는 스파게티코드에 가까운 걸 함수형 표현으로 잘 리팩토링하는게 첫 미션

두번째는 만들어진걸 고차함수를 이용해서 실행하는 것

함수를 추상화하면 차원이 높아진다고??? 응???

리턴으로 함수를 쓰면 고차함수의 일종??? 매개변수나 리턴을 함수로 써?? 함수의 중첩을 말하는 것?????

자바는 스트림 api. 맵 리듀스, 필터 같은걸로 함수형 프밍의 맛을 볼 수 있다?

포문으로 처리하던걸 함수형 프밍으로 처리가능?????

첫 미션은 그냥 여깄는 코드를 함수형 프밍으로 바꾸는 것?

두번째에 첫 미션의 힌트가 있다. 두번째는 첫 미션을 가지고 고차함수(맵, 필터, 리듀스)를 활용해서 구현해봐라.

익숙하지 않아? 그럼 간단한 튜토리얼이나 검색을 통해 맛을 봐라.

객체지향은 유지보수와 가독성이 굉장히 큰 축?

함수형 프밍은 역시 마찬가지. 유지보수 + 가독성 + 멀티코어, 분산시스템에서 사이드 이펙트를 없애서 병렬프밍을 용이하게 하는게 목적? 여튼 리엑티브 선언문도 찾아보는게 좋겠죠 여기서 끝내겠음.



***

## 코딩일일결산
#### 내일의 나에게 보내는 전달사항

#### GOOD

* 

#### BAD

* 



#### 리액티브 선언문

예전보다 애플리케이션에 대한 요구사항이 높아졌다. 더 빨리 응답시간이 요구되고, 처리해야 하는 데이터량도 많아졌다. 응답이 잘 되고, 탄력적이며 유연하고 메시지 기반으로 동작하는 시스템을 리액티브 시스템이라고 한다. 리액티브 시스템으로 구축하면 유연하고 느슨한 결합을 가지면서, 확장성이 높다. 덕분에 요구사항 변경에 대응하기 쉬워진다. 또한 장애에 대한 강한 내성이 있어서 간결한 방식으로 해결할 수 있다.

##### 응답성

신뢰할 수 있는 상한선을 설정하고, 일관된 서비스 품질을 제공한다

##### 탄력성

시스템이 장애에 직면해도 응답성을 유지한다면, 탄력성이 있다고 부른다. 이게 없으면 장애발생시 응답성을 잃어버린다. 이건 복제, 봉쇄, 격리, 위임에 의해 실현된다는데, 아직 이게 뭔지 잘 모르겠어서, 어떻게 탄력성을 가진다는건지는 잘 모르겠다. 일단 알 수 있는건, 장애가 발생해도 응답성을 잃지 않는, 탄력성이 있는 시스템을 만들어야 한다는 것이다.

##### 유연성

시스템이 작업량이  변화해도 응답성을 유지한다. 변화에 잘 대응해서 병목현상이 존재하지 않도록 설계하고, 부하를 분산시킨다

##### 메시지 구동

비동기 메시지 전달에 의존한다. 덕분에 구성요소 사이에서 느슨한 결합, 격리, 위치 투명성을 보장하는 경계를 형성한다...? 이 경계는 장애를 메시지로 지정하는 수단을 제공한다는데, 뭐지...? 여튼 메시지 큐를 생성하고, 이걸 모니터링하면서 배압이란걸 적용해서 유연성을 부여하고 부하관리나 흐름제어가 가능하게 한단다. 아. 근데 쉽게 이해하긴 어려운 내용들이다. 일단 여기까지만 정리하고, 나중에 더 내공이 쌓이면 그때 다시 보자. 

그나저나 이게 왜 이해하기 어려운가 라고 물어본다면, 그건 내가 결합도가 높아지면 왜 문제가 생기는지를 잘 모른다거나, 위치투명성이라는 말의 의미를 이해하지 못하는 등, 기초지식이 얕기 때문에, 리액티브 선언문을 이해하기 어렵다고 말한 것이다. 그래서 더 공부해야 이해할 것 같다고 말한 것이다.

일단은 리액티브 선언문이라는게 더 빠른 응답시간을 일관성있게 보장하며, 부하를 유연하게 분산시키는데다가 요구사항 변경에 대응하기 쉽고 장애에 대처하기 좋은 아주 멋진 시스템이란건 알겠다. 문제는 왜 그런건지를 잘 이해하지 못하는게 문제지만. 근데 서버에 대해 좀 더 지식이 쌓이면 이해할 수 있지 않을까?



##### FunctionalInterface는 또 뭘까?

람다표현식을 쓰려면, @FunctionalInterface어노테이션을 써야 한다. 아니라면, 컴파일타임에러가 발생한다??? 그 외에도 사용자가 봤을 때 FunctionalInterface이면 람다표현식을 쓸 수 있구나! 하고 알 수 있다.

Runnable인터페이스 타입으로 람다표현식을 넘기거나 받을 수 있다. Runnable인터페이스가 @FunctionalInterface로 선언되어 있어서 그렇다.

##### FreeVariable과 Final.

예전엔 FreeVariable은 반드시 final로 선언해야 했다. 안그러면 컴파일 에러가 발생했다. 근데 java8부터는 final이 아니어도 된다. 이야 그럼 final아니니까 값을 변경할 수 있겠네? 하고 값을 변경하려고 들면, 못한다. 사실상 final인데 굳이 선언에 final을 붙일 필요가 없는 것일 뿐이다. 이걸 **Effectively Final**이라고 부른다. 단지 편의를 위해서 final을 안적어도 된다 라고 만든 것 뿐이다. final처럼 써야 문제가 생기지 않는다.

final을 안붙인 상태에서 람다표현식에 FreeVariable을 넘기는데, 이 변수의 값을 수정한다면? 에러가 발생한다. 람다표현식에서 변수를 쓰려면, final이거나 Effectively Final이어야 하는데, 지금 이걸 어겨서 그렇다. 람다표현식을 넘기기 전에 값을 바꾸던, 넘기고 난 다음 바꾸던 에러는 발생한다.

##### 그래서 왜 FreeVariable은 Final이거나 Effectively Final이어야 하는걸까? 

멀티스레드에서 RaceCondition이 발생할 수 있기 때문에 저렇게 만들어 놨다고 한다. 만약 자유변수가 Final이 아니라고 가정해보자. 싱글스레드라면 한 순간에 실행될 수 있는 실행흐름이 애초에 하나니까 람다표현식으로 넘긴 함수가 실행되고 있는데, 건드리지도 않은 FreeVariable값이 갑자기 바뀐다거나 하는 문제거 없을 것이다.

근데 이제 멀티스레드 환경이라면, 한 순간에 실행될 수 있는 실행흐름이 여러개일 수 있다. T1이 FreeVariable을 읽으려는데 그 전에 T2가 FreeVariable값을 바꿔버렸다면? T1은 람다표현식을 넘겼을 때의 FreeVariable 값을 가지고 계산해야 하는데, 도중에 누가 값을 바꿔버린다면, 의도된 계산결과가 나오지 않을 것이다. 그래서 final로만 FreeVariable을 쓸 수 있게 만들어 놨다고 한다.

##### 변수를 캡쳐한걸까 아니면 변수의 값을 캡쳐한걸까?

변수를 캡쳐한게 아니라 값을 캡쳐한거라고 한다. 람다표현식에 해당하는 인스턴스가 런타임에 생성되면, 이때 FreeVariable에 대한 정보를 가지고 있는게 아닌, 그 변수의 값을 캡쳐해간다. 그래서 이 값이 바뀌면 안된다.