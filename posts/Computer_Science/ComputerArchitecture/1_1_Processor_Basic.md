---
sort: 1
title: 프로세서의 구성
tags: [ 컴퓨터구조 ]
---


## 프로세서의 구성 ( ALU, 제어장치, 레지스터, 내부 버스 )

### ALU

##### ALU가 할 수 있는 연산

* 사칙연산

* 논리연산 ( AND,        OR, NOT )

* 비트연산

* 시프트연산

##### ALU가 연산을 하는 과정

1. 수행하고자 하는 연산의 피연산자(오퍼랜드)를 읽어들인다

2. 연산한다

3. 목적 레지스터나 메모리에 결과를 저장한다.

##### ALU에서 연산을 선택하는 방법은?

기계어 명령어에는 ALU에서 어떤 연산을 해야 하는지가 지정되어 있다. 여기에 지정된 연산을 선택해서 수행한다.

##### ALU 연산의 구조

* 이항연산을 기준으로 한다. 그래서 두개의 입력과 하나의 출력을 갖는다.

* 두개의 피연산자(오퍼랜드)가 입력으로 들어간다

* 연산결과값은 지정된 곳에 저장된다. 보통 상태 레지스터에 저장됨.

* 상태 레지스터엔 캐리, 음수, 제로플래그가 있다.

### 제어장치

제어장치는 프로세서의 클록신호를 기반으로 레지스터와 ALU를 제어한다

한 클록 사이클 내에 수행되는 프로세서내의 동작을 마이크로 연산이라고 한다

제어장치는 명령어에 따라 필요한 마이크로 연산을 지정하고, 수행에 필요한 제어신호를 발생시킨다.

제어신호는 이런게 있다.

* 각 명령어 실행 단계의 순차적 제어 클록 발생

* 명령어 인출과 해독

* 유효주소 계산 및 오퍼랜드 인출

* ALU에 대한 연산, 입출력 지정

* 메모리 읽기 쓰기 신호

##### 순차적인 제어신호를 생성하는건 어떻게 구현하는가

두가지 방법이 있다. 하나는 HardWired, 다른 하나는 MicroProgrammed 이렇게 두 방식이 있다.

HardWired방식은 논리회로를 써서 제어신호 생성을 구현한것이다.

MicroProgrammed방식은 마이크로명령어로 제어신호를 발생시킨다.

##### 마이크로 명령어란?

제어신호를 발생시키는 프로그램을 만들어서 제어신호를 만드는게 MicroProgrammed방식이다. 이 프로그램을 만들때 쓰는게 마이크로 명령어이다.

### 레지스터

데이터나 명령어를 일시적으로 저장하는 고속 메모리이다.

RAM과 같은 주 메모리에 대한 접근은 너무 느리다. 프로세서가 데이터를 일시적으로 저장하거나 결과를 저장할때마다 메모리에 접근하는건 비효율적이다.

그래서 메모리보다 훨씬 빠른 레지스터를 대신 쓴다. 메모리에서 데이터를 인출해오는거랑, 레지스터에 저장해두고 레지스터를 접근해서 인출해오는거랑 비교해보자. 당연히 레지스터에서 인출해오는게 더 빠르니까 그만큼 명령어를 더 빨리 실행할 수 있다.

그렇다고 레지스터를 무한정 많이 넣을 수는 없는게, 가격문제도 있고 프로세서 크기나 복잡성 문제가 있어서 그렇게는 못한다.

#### 전용 레지스터(Special Register)

레지스터가 특정한 용도로만 쓰이는 경우이다.

프로그램 카운터, 상태 레지스터, 주소 레지스터, 명령어 레지스터등이 그 예이다.

#### 주요 전용 레지스터

##### 프로그램 카운터(PC)

프로세서가 다음에 실행할 명령어의 주소가 이 레지스터에 저장된다. 그래서 얘가 프로그램의 실행을 제어하게 된다. 얘를 읽고 다음에 실행할 명령어의 주소를 얻으니까.

PC는 보통 자동적으로 증가한다. 명령어 실행하고 나면 다음 명령어를 실행해야하니까?

근데 인터럽트되거나 분기로 갈리면, 즉 분기명령, 인터럽트 명령어가 실행되면 자동증가하는게 아니구, 목적지 주소의 값으로 변경된다.

##### 상태 레지스터

명령어 실행 후의 상황을 나타낸다. 이걸 조건 플래그라고 부르는 모양이다.

상태값으로는 N(Negative), OV(OverFlow), Z(Zero), DC(Digital Carry), C(Carry) 플래그 비트가 있다.

앞서 명령어 실행 후의 상황을 나타낸다고 했는데, 가령 연산결과가 0이면 상태 레지스터의 제로플래그의 비트가 1이 된다.
이걸로 조건부 처리명령에 의해 프로그램의 흐름을 제어하는데 사용될 수 있다고 한다.

##### 누산기(AC) 레지스터

요 레지스터에 ALU가 연산한 결과값이 일시적으로 저장된다.

##### 주소 레지스터 ( MAR | 기억장치 주소 레지스터 )

인출할 명령어 또는 데이터 메모리의 주소를 일시적으로 저장하는 레지스터이다.

##### 명령어 레지스터 ( IR )

인출한 명령어를 일시적으로 저장하는 레지스터이다.

##### 스택 레지스터

인터럽트, 서브루틴 콜을 실행할 때 프로그램 카운터나 상태 레지스터등의 값을 잠시 저장해둘 필요가 있을 때, 
    스택 레지스터에 저장한다. 

여러개의 레지스터 형태로 구성된다.

##### 스택 포인터 ( SP )

스택 메모리에 접근하려면 스택 포인터를 통해서 접근해야 한다.

아까 프로세서가 데이터를 나중에 쓰려고 스택 레지스터에 값을 저장(푸시)한댔는데,
    다시 읽어오려면? 팝을 해야한다. 스택이고, 푸시했으니 팝으로 꺼내는 것.

푸시할 때, 스택 포인터 값을 하나 증가시키고, 스택포인터가 지정하는 주소에 데이터를 쓴다.

팝을 하면 스택포인터가 지정하는 주소로부터 값을 읽고, 스택 포인터 값을 하나 감소시킨다.

정리하자면, 인터럽트, 서브루틴 호출 같은 걸 실행할 때 지금 프로그램 카운터나 상태레지스터등의 값을 보존하고 싶을 때, 스택 레지스터를 쓴다. 값을 넣을때마다 스택에 푸시하는데, 이때 스택 포인터를 하나 증가시키고, 얘가 가리키는 스택 레지스터에 값을 저장한다. 반대로 꺼낼 땐, 스택포인터가 가리키는 레지스터에서 값을 읽은다음, 스택포인터를 하나 감소시킨다.

#### 범용 레지스터(General Register)

일반적인 데이터, 연산결과 등을 일시적으로 저장하는데 쓴다. 명령어 수행에 필요한 특수한 데이터를 저장하는게 아니다. 근데 범용레지스터도 각기 이름이 부여되어 있다.

##### 내부 버스

프로세서안에도 데이터, 주소, 제어버스가 있고, 외부 버스와 연결되어있다.

외부 시스템과 직접 연결되는건 아님. 버퍼 레지스터나 시스템 버스 인터페이스를 통해 연결됨.

장치들에 전기신호를 보내기 위해 버스를 이용한다

##### 버스의 폭

정보를 전달하는 신호 선의 수. 한번에 전달할 수 있는 단위이다.
    64비트 데이터버스이면 64비트의 데이터를 한번에 전달할 수 있다.

##### 데이터 버스

ALU와 레지스터 간의 데이터 이동을 위한 버스

그 외에도 외부장치인 메모리나 입출력장치로부터 데이터를 읽거나 쓸 때의 데이터 이동에도 필요하다.

그래서 양방향 버스임.

##### 주소 버스

주소들로 구성된 내부버스이다.

프로세서에서 출력되는 것으로 메모리 또는 입출력장치의 주소를 지정한다

```note
라고 책에 쓰여있는데, 이 부분은 잘 이해가 가지를 않는다. 좀더 읽어봐야겠다.
```

##### 제어 버스

제어장치에서 발생된 신호를 프로세서의 장치에 보내는데 쓰는 버스

외부장치를 제어하기 위해서도 쓴다. 읽기 쓰기, 인터럽트 처리를 위한 제어 버스가 있다.

## 프로세서가 명령어를 처리하는 과정

1. 프로그램카운터라는 레지스터에 지정되어 있는대로 메모리에서 명령어를 인출한다

2. 인출되는 명령어는 프로세서의 레지스터에 저장된다.

3. 프로세서는 명령어가 어떤 종류인지 해독한다

4. 해독해서 알아낸 종류에 따라 명령어가 실행된다

5. 기계어 명령어에 의해 정해진 과정을 통해, 실행 단계별로 필요한 제어신호가 발생된다.