---
sort: -13
title: TIL-13, 열세번째.
tags: [ TIL, 함수형프로그래밍, 람다 ]
---

## 오늘은 어땠을까

컨디션 : 피곤하고 졸림. 잠을 잘 못잤음.



***

##### 오늘 할 일

- [x] 리액티브 선언문 읽어보기
- [x] 함수형 프로그래밍이 뭔지 간단하게 알아보기
- [x] 람다대수에 대해 간단하게 알아보기
- [x] 함수형 프로그래밍의 특성에 대해 알아보기
- [x] Java의 람다표현식과 익명클래스를 비교해서 공부하기(영상보면서)
- [ ] 함수형 프로그래밍을 적용해서 미션1 풀기
- [ ] 영어공부

##### 남은 시간이 부족하므로 아래의 작업은 오늘 하지 않는다.

- [ ] ~~코테문제 풀기~~
- [ ] ~~객체지향의 사실과 오해를 읽고 정리하기~~
- [ ] ~~고차함수가 뭔지 간단하게 알아보고 map, reduce, filter를 써서 미션 2 풀기~~



## 오늘 배운 내용  
### 함수형 프로그래밍과 람다 계산

#### 함수형 프로그래밍이 뭘까?

##### 함수형 프로그래밍의 정의

> **함수형 프로그래밍**(functional programming)은 자료 처리를 [수학적 함수](https://ko.wikipedia.org/wiki/함수)의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 [프로그래밍 패러다임](https://ko.wikipedia.org/wiki/프로그래밍_패러다임)의 하나이다. [명령형 프로그래밍](https://ko.wikipedia.org/wiki/명령형_프로그래밍)에서는 상태를 바꾸는 것을 강조하는 것과는 달리, 함수형 프로그래밍은 함수의 응용을 강조한다. 프로그래밍이 [문](https://ko.wikipedia.org/wiki/문_(프로그래밍))이 아닌 식이나 선언으로 수행되는 [선언형 프로그래밍](https://ko.wikipedia.org/wiki/선언형_프로그래밍) 패러다임을 따르고 있다. 
>
> *by 위키백과 [함수형 프로그래밍](https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)*

일단은 **자료처리를 수학적 함수의 계산으로 취급**하고, **상태와 가변데이터를 멀리하겠다**는 말부터 이해해야 할 것 같다. 

```note
좀 더 정리해보니, 상태와 가변데이터를 멀리하겠다는 말의 의미를 조금 알 것 같다.
함수형 프로그래밍의 함수는 순수함수이다. 따라서 외부의 객체나 상태에 영향받지 않는다.
그 덕분에 부작용(Side Effect)이 없다.
이게 바로 상태와 가변데이터를 멀리하고 있는게 아닐까?
또한 순수함수는 수학적 함수와 그 성질이 비슷하다고 할 수 있다. 같은 입력이 주어지면 항상 같은 출력이 나오기 때문이다. 함수형 프로그래밍을 하겠다는 말은, "단순히 함수를 많이 쓰겠어요." 라고 하는게 아닌, 수학적 함수를 이용해서 프로그래밍 하겠다는 말이 아닐까? 
```

##### 함수형 프로그래밍이 필요한 이유

>  명령형의 함수는 프로그램의 상태의 값을 바꿀 수 있는 부작용이 생길 수 있다. 이 때문에 명령형 함수는 **참조 투명성**이 없고, 같은 코드라도 실행되는 프로그램의 상태에 따라 다른 결과값을 낼 수 있다. 
>
> *by 위키백과 함수형 프로그래밍 두번째 문단*

명령형의 함수는 프로그램의 상태값을 바꿀 수 있다? 그래서 **참조 투명성**이 없다? 그래서 같은 코드라도 실행되는 프로그램의 상태에 따라 다른 결과값을 낼 수 있다? 이게 무슨 의미일까? 그러면 명령형의 함수라는건 프로그램의 상태값을 바꿀 수 있는데다가 이것의 영향을 받기 때문에, 프로그램의 상태에 따라 결과값이 달라진다는 의미인가? 다른건 모르겠지만, 일단 명령형의 함수는 프로그램의 상태에 영향을 받는다는건 알겠다. 여기서 같은 코드라는게 아무래도 같은 입력을 말하는 것 같은데, 입력이 같아도 얼마든지 결과값이 달라질 수 있다는 것을 말하는 것 같다.

> 반대로 함수형 코드에서는 함수의 출력값은 그 함수에 입력된 인수에만 의존하므로 인수 x에 같은 값을 넣고 함수 f를 호출하면 항상 f(x)라는 결과가 나온다. 부작용을 제거하면 프로그램의 동작을 이해하고 예측하기가 훨씬 쉽게 된다. 이것이 함수형 프로그래밍으로 개발하려는 핵심 동기중 하나이다.
>
> *by 위키백과 함수형 프로그래밍 두번째 문단*

함수형 프로그래밍에서의 함수는 입력된 인수에만 의존한다. 즉 프로그램의 상태에 영향을 받지 않기 때문에, 같은 코드(입력)라면, 항상 같은 결과가 나온다. 확실히 이렇게만 되면 프로그램의 상태를 안봐도 결과를 예측할 수 있으니 동작이해하고 결과를 예측하기 편하겠다.

##### 함수형 프로그래밍을 위해 쓰이는 람다 계산

> [알론조 처치](https://ko.wikipedia.org/wiki/알론조_처치)가 1930년대에 개발한 [람다 대수](https://ko.wikipedia.org/wiki/람다_대수)는 함수에 대한 이론적 기반을 세웠다. 이것은 프로그래밍 언어가 아니라 수학적 추상화였지만, 이것은 함수형 프로그래밍의 근간을 이루었다.
>
> *by 위키백과 함수형 프로그래밍 - 역사*
>
> 
>
> 함수형 프로그래밍은 1930년대에 계산가능성, 결정문제, 함수정의, 함수응용과 재귀를 연구하기 위해 개발된 형식체계인 [람다 대수](https://ko.wikipedia.org/wiki/람다_대수)에 근간을 두고 있다. 다수의 함수형 [프로그래밍 언어](https://ko.wikipedia.org/wiki/프로그래밍_언어)들은 람다 연산을 발전시킨 것으로 볼 수 있다.
>
> *by 위키백과 함수형 프로그래밍 - 첫번째 문단*

아직은 람다 계산이 뭔지 잘 모르겠지만, 일단 이게 함수에 대한 이론적 기반을 세웠다고 한다. 근데 어떤 기반을 세운걸까? 이게 뭐길래? 뭘 했길래? 여튼간에 다수의 함수형 프로그래밍 언어는 람다연산을 발전시킨 것으로 볼 수 있다고 한다. 일단 람다가 뭔지부터 알아봐야겠다.

### 람다 계산(Lambda Calculus)

> [함수](https://ko.wikipedia.org/wiki/함수)는 [컴퓨터 과학](https://ko.wikipedia.org/wiki/컴퓨터_과학)과 [수학](https://ko.wikipedia.org/wiki/수학)의 기초를 이루는 개념이다. 람다 대수는 함수를 단순하게 표현할 수 있도록 하여 '함수의 계산'이라는 개념을 더 깊이 이해할 수 있게 돕는다.
>
> *by 위키백과 [람다 대수](https://ko.wikipedia.org/wiki/%EB%9E%8C%EB%8B%A4_%EB%8C%80%EC%88%98) 도입 - 함수의 표현*

#### 람다 계산은 다음과 같은 특징이 있다

* 람다 계산은 **함수를 단순하게 표현할 수 있도록 해준다.** 

* 람다 계산은 **반드시 이름을 가질 필요가 없다**.

   ![{\displaystyle (x,y)\mapsto x\times x+y\times y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/cb7ae3435d6d9913ac8ecce1db0dbb8a96784efe)이런 식으로 쓸 수 있다.

* **입력변수의 이름도 필요 없다.**

  ![{\displaystyle (x,y)\mapsto x\times x+y\times y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/cb7ae3435d6d9913ac8ecce1db0dbb8a96784efe)이것과 ![{\displaystyle (u,v)\mapsto u\times u+v\times v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1b077445481c061950e6279012dd16eab70031a0)이 람다식은 변수의 이름은 다르지만, 같은 함수이다.

* **두개 이상의 입력을 받는 함수는 하나의 입력을 받아 또다른 함수를 출력하는 함수로 다시 쓸 수 있다.** 

  요 표현이 좀 이해가 잘 안가는데, 우선 ![{\displaystyle (x,y)\mapsto x\times x+y\times y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/cb7ae3435d6d9913ac8ecce1db0dbb8a96784efe)이런 함수를 ![{\displaystyle x\mapsto (y\mapsto x\times x+y\times y)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/680dc9e0a184c55cddda96209dd662e046350b0b)이런 형태로 다시 쓸 수 있단다. 

  그럼 이 함수를 s라고 했을 때, s(x, y)는 

  ![{\displaystyle (x\mapsto (y\mapsto x\times x+y\times y))(5)(2)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6adb05233edc5dceb3514c798e2dcdca1f3e3810) 여기서 x -> 랑 y -> 를 단일입력함수라고 부르는 모양이다. 

  단일입력함수를 두번 적용하게 된다.

  ![{\displaystyle =(y\mapsto 5\times 5+y\times y)(2)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/bcccc2a0da907bee310607459d6140e075bf3fb6) 

  ![{\displaystyle =5\times 5+2\times 2}](https://wikimedia.org/api/rest_v1/media/math/render/svg/478f541281ad581779c08198d3ce706443b4bcf0) 

  아, 그러니까 원래는 두개의 입력을 받는 함수였는데, 하나의 입력을 받는 함수로 고쳐쓰는게 된다는 걸 표현하고 싶었던 예제인거구나. 그러니까 람다함수의 결과를 다른 람다함수의 입력으로 넣을 수 있는 모양이다.

#### 핵심개념 : 람다 계산으로 표현하기

* ![{\displaystyle \lambda x.t}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6c340da553f36c8832a4a6aff7d235dd2acb760a) 단일입력 x를 받아 표현 t로 표현하는 익명함수를 이렇게 표현한다.

  **λx. x^2 + 2**는  **f(x) = x^2 + 2**를 **람다 계산**으로 **추상화**한 것이다. 

  람다 추상화를 통해 함수를 정의한다는 건, 함수 f(x)를 람다식으로 정의만 하고, 호출하진 않는 것을 의미한다.

* **자유변수**

   [출처 : Introduction to the lambda calculus](http://www.cs.columbia.edu/~aho/cs4115/Lectures/15-04-13.html)

  람다 추상화를 통해 표현에 묶이지 않은 변수를 말한다. 여기서 말하는 표현은 왼쪽의 람다표현을 말한다.

  **λx. x**의 변수 x는 **λx**표현에 묶여있다. 그래서 x는 자유변수가 아니다
  
  **λx. xy**의 반면 y는 표현에 묶여있지 않다. 그래서 y는 자유변수이다.

```note
앞에서 다수의 함수형 프로그래밍 언어는 람다계산을 발전시킨 것으로 볼 수 있다는 말이 나왔다.
왜 위키에 그렇게 적혀있나 궁금했는데, 람다계산을 쓰면 함수를 단순하게 표현할 수 있어서 그런게 아닐까?
그래서 함수형 언어에서 람다계산으로 함수를 표현하는게 아닐까 라는 생각이 들었다.
***
근데 추가로 더 정리해보니, 자바에서 말하는 자유변수개념이 위의 자유변수에 대한 설명이랑 무슨 관계가 있는지 연결해서 이해하기가 어렵다. 일단은 [영상](https://www.youtube.com/watch?v=pjtk7vvryio&feature=youtu.be)에서 본 내용으로 이해하도록 하자.
```

### 다시 함수형 프로그래밍으로 돌아오자

#### 함수형 프로그래밍의 순수함수(Pure Function)

* 순수한  함수는 수학의 함수처럼 같은 입력이 주어지면 항상 같은 결과를 출력해야 한다. 
* 함수형 프로그래밍 언어에서는 함수를 순수함수라고 부른다.
* 순수한 함수는 부작용(Side Effect)이 없다.
* 함수의 실행이 외부에 영향을 끼치지 않는다
* 순수한 함수는 스레드 안전하고 병렬적인 계산이 가능하다. 

순수함수는 외부값이나 객체에 의존하지 않는다. 외부에 의존하지 않고 입력받은 패러미터만 가지고 동작하기 때문에, 부작용이 없다. 이를 **참조투명성**이라고 한다. 만약 순수함수가 아니라면, 입력받은 패러미터 외에 다른 값을 참조해서 동작한다. 따라서 외부값에 의해 다른값이 리턴될 수 있는 **부작용**이 있다.

```note
자바의 람다표현식은 표현식에서 접근하는 모든 자유변수를 final이나 Effectively Final로 취급해야한다.
왜 그럴까? 람다표현식으로 표현한 함수를 순수함수로 쓰기 위해서가 아닐까?
```

#### 클로저(Closure)?

* 루카스에서 본 클로저에 대한 설명은 아래와 같다.
* 클로저란 람다 계산의 구현체이다.
* 선언된 범위(Scope)에서 접근가능한 변수를 캡쳐해서 저장하고 닫힌다.
* 클로저는 캡쳐한 변수를 참조(Reference)한다
* 이것만 봐선 뭔지 잘 모르겠다. 영상을 보고 공부해보자.

##### 영상을 보고 정리한 클로저

[출처 : 모던 자바. 못다한 이야기 - 클로저](https://www.youtube.com/watch?v=pjtk7vvryio&feature=youtu.be)

```java
int i = 100;
someMethod ( x -> x * 2 + i)//엄밀히 말해서 이 람다표현식은 익명함수가 된다.또는 익명 메서드.
```

* 여기서 x는 패러미터이고, 2는 상수값이다. 넘어가자.

* 그러면 i는 뭘까? i는 람다표현식 밖의 None-Local Variable이다.

  이걸 다른말로 **자유변수(Free Variable)**이라고도 부른다

* 여하튼 이런 식으로 익명함수가 스코프 **외부의 변수**에 접근하면, 우리는 이걸 특별히 **클로저라고 부른다**.

![image-20210118160300843](image-20210118160300843.png) 

보면 익명함수의 원래 스코프는 빨강색까지가 함수의 스코프다. 근데 지금 이 람다표현식에서 외부의 변수에 접근하고 있다. 이때, **스코프의 범위를 확장해서 파란색으로 색칠한 저기까지로 덮어버린다**. 이걸 다른말로  **Close Over**한다 라고 불러서, 이런걸 클로저라고 부른단다. 여하튼 스코프를 자유변수까지 확장해주기 때문에 표현식에서 접근할 수 있게 된다.

  > close over
  >
  > *phrasal verb*
  >
  > close over somebody/somethingto surround and cover somebody/something

한가지 주의할 점이 있는데, 변수 자체에 대한 정보를 캡쳐하는게 아닌, 변수의 값을 캡쳐하는 것 이라고 한다.

##### 예제로 다시 한번 정리해보기

```java
class ClosureExample{
    int num = -200;
    public void test(){
        int num = 1;
        //람다 표현식을 아규먼트로 넘기는 테스트 코드
        testClosure( "Test Lambda", () -> {
            System.out.println(num);
            System.out.println("this.num : " + this.num);
        });
        testClosure("Test Anonymous", new Runnable() {
            @Override
            public void run() {
                System.out.println(num);
                System.out.println("this.num : " + ClosureExample.this.num);
            }
        });
    }//test()
}//class ClosureExample
```

* 인클로징 클래스의 변수에 접근하는 경우, 스코프의 범위를 자유변수까지 확장해서 덮어버린다.(Close Over)

  그래서 이걸 **클로저**라고  부른다

* 익명클래스건 람다표현식이건, 자유변수는 Final 또는 Effectively Finally로 취급해야 한다. 값을 바꿀 수 없다.

* 익명클래스의 this는 Runnable인터페이스로 만든 익명클래스의 인스턴스이다. EnclosingClass인 ClosureExample클래스의 인스턴스를 가리키지 않는다.

* 반면, 람다표현식의 경우, this 키워드는 인클로징 클래스인 ClosureExample클래스의 인스턴스를 가리킨다.

  ```note
  영상에선 람다표현식은 표현식 자체에 대한 스코프가 없어서 그렇다고 한 것 같은데, 이 부분은 잘 이해하지 못했다. 추가적인 공부가 필요하겠다. 일단은 람다표현식 안에서의 this키워드는 인클로징 클래스의 인스턴스를 가리킨다고 알고 있자. 추가로 모던자바 클로저 9-1 50:13까지 봤다. 이어서 볼 때 참고하자.
  ```

### 정리하면......

#### 람다함수는 함수를 단순하게 표현하게  해주는 표현식이다.

정리하면, 람다 대수는 함수를 단순하게 표현할 수 있게 해주며, 이름이 필요없다(익명함수). 변수의 이름도 필요없어서 다른 람다표현이면 같은 이름의 변수일지라도 다른 변수이다. 두개의 입력을 받는 함수를 하나의 입력을 받아 또 다른 함수를 출력하는 함수로 고칠 수 있다. 어떤 함수의 출력을 다른 함수의 입력으로 쓸 수 있다는걸 말하는 것 같다. 그리고 람다표현에 묶여있지 않은 변수를 자유변수라고 부른다.

#### 함수형 프로그래밍의 함수는 순수함수이다.

순수함수는 같은 입력이 들어가면 항상 같은 출력이 나오는 함수이다. 또한 참조투명성을 가져야 하기 때문에, 외부값이나 객체에 참조하지 않는다. 다시말하면 의존하지 않는다고 표현할 수 있다. 이러한 참조투명성 덕분에 부작용(Side Effect)이 없다. 외부 값에 의해 결과가 달라지지 않는다. 오직 입력받은 패러미터만을 가지고 동작한다.

#### 클로저는 람다계산의 구현체이다.

클로저는 선언된 범위에서 접근가능한 변수를 캡쳐해서 저장하고 닫힌다. 람다계산은 동작을 위해 캡쳐한 변수를 참조하게 된다.

> 람다 클로저는 람다식이 범위를 둘러싼 (글로벌 또는 로컬) 변수를 참조 할 때 만들어집니다. 이 작업을 수행하는 규칙은 인라인 메서드 및 익명 클래스의 규칙과 동일합니다.
>
> 람다 안에서 사용되는 엔 클로징 스코프의 *로컬 변수* 가 `final` 이어야합니다. Java 8 (람다를 지원하는 가장 초기 버전)을 사용하면 외부 컨텍스트에서 `final` *선언* 할 필요는 없지만 그렇게 처리해야합니다.
>
> [RIP 튜토리얼 람다식이 있는 java closure](https://riptutorial.com/ko/java/example/14441/%EB%9E%8C%EB%8B%A4%EC%8B%9D%EC%9D%B4%EC%9E%88%EB%8A%94-java-closure-)

#### 함수형 프로그래밍 언어에서의 함수는 1급객체(First Class Object)이다

그래서 함수를 타입으로 지정하거나 패러미터로 넘기거나 리턴할 수 있다.

#### 클로저는 익명함수에서 접근하는 외부의 자유변수까지 스코프를 확장해서 캡쳐하고 닫히는 구현체를 말한다?

아니 그래서 뭐가 클로저인거지...? 람다함수도, 익명함수도 스코프를 외부까지 확장해서 캡쳐하고 닫으면 클로저라고 부를 수 있는건가?

#### 람다가 없으면 함수형 프로그래밍을 못하는걸까?

루카스를 보면 람다가 없던시절이랑 람다가 있던 시절을 비교해서 설명했다. 처음엔 이게 나오는 의미를 잘 몰랐다. 일단 지금 드는 생각으로는, 우리가 해야하는건 함수형 프로그래밍을 하고 싶은거고, 그러기 위해선 함수를 패러미터로 보내거나 타입으로 지정하거나 리턴할 수 있어야 한다. 그러면 이걸 어떻게 구현할 수 있을까?

익명클래스를 쓰면 된다. 익명클래스로 만들고, 이걸 패러미로 받은 쪽에서 익명클래스.runFunc()한다고 치면, runFunc()메서드를 정의해서 넘기면 된다.

근데 우린 함수만 넘기고 싶었던 건데 굳이 익명클래스까지 넘겨야 하는걸까? 라고 생각한다면, java8부터는 람다표현식을 쓸 수 있기 때문에, 굳이 익명클래스를 쓸 이유가 없겠다.

일단 람다가 없어도 익명클래스를 쓰면 주고받고 다 할 수 있는데다가 익명클래스도 자유변수에 대한 접근은 final하게 해야 하기 때문에 못하는건 없다고 생각하지만, 엄청 코드가 지저분해질 것 같다.

### 함수형 프로그래밍 연습

- 불변성 (Immutable) 값이나 변수를 적극 활용해야 한다.

  람다표현식을 쓰는 경우, 표현식에서 참조하는 인클로징 클래스의 모든 변수는 final이나 Effectively Final로 쓰게 된다. 그래서 값이 바뀌지 않는다. 

  ```note
  이런 특성 덕분에 멅티스레드 환경에서 쓸 수 있다고 하는건가? 추가적인 공부가 필요하겠다.
  ```

- 함수가 참조 투명성을 지키고, 부작용을 줄일 수 있도록 구현해야 한다.

  앞서 정리한 것 처럼, 순수함수내에서 외부값이나 객체를 참조하지 않도록 해야 한다. 외부에 의존하면 참조투명성이 없게 되어 부작용(Side Effect)이 발생할 위험이 생긴다.

- 순수함수 (Pure Function) 로 구현해야 한다.

  같은 입력이 들어오면 항상 같은 출력이 나가도록 구현해야 한다.



***

## 코딩일일결산

#### 내일의 나에게 보내는 전달사항

#### GOOD

* 

#### BAD

* 