---
sort: -27
title: TIL-27, 스물일곱번째.
tags: [ TIL ]
---

# 오늘 할 일

- [ ] HTTP프로토콜에 대한 간단한 정리를 하기
- [ ] 코드플러스에서 강의듣고 문제풀기
- [ ] 토끼책 읽기
- [ ] SQL책 읽기
- [ ] 

# 오늘 배운 내용  

## 마스터즈 클래스

버스

뭔가를 실어나르기도 하지만, 모든 곳을 다 들린다.

컴퓨터구조에서도 그럴까?

엔드포인트. 끝단. 

![image-20210202104143829](image-20210202104143829.png)

버스라는 개념과 비슷. 터미널에서 터미널로 가는 것처럼. 끝단, 엔드포인트라는 개념이 있다

트랜스미터와 리시버는 줄여서 tx rx라고도 한다. 실전화기가 그런 것처럼 컵전화기는 한쪽은 말만하고 한쪽은 들을 수 만 있다. rxtx가 내가 말하면서도 듣고 싶다 그러면 rxtx가 양방향으로, 풀 듀플랙스로 선이 두가닥씩 있어야 한다. 그래야 양방향 통신이 가능해진다. 이런 통신의 기본적 개념이 노드. 노드가 다른 노드로 연결된다.

오퍼레이터? 델레폰 익스체인저. 교환원은 송신자가 수신자와 연결될 수 있게 도와주었다. 선을 계속 연결해준다. 스위치, 선을 연결해준다. PSTN

![image-20210202104503063](image-20210202104503063.png)

![image-20210202105151236](image-20210202105151236.png)

이어진게 아날로그, 다 끊어져 있는게 디지털? 

![image-20210202105319510](image-20210202105319510.png)

아날로그를 디지털신호(이산신호)로 변환한다. 코드로. 어떠한 아날로그 신호를 디지털 신호로 변환해야 한다.

![image-20210202105445919](image-20210202105445919.png)

이때 아날로그 신호를 띠엄띠엄 쪼개서, 일정한 간격의 디지털 신호로 만든다. 이를 샘플링이라고도 하고, PCM이라고도 한다. Pulse Code Modulation

아날로그 신호중에서 가장 높은 주파스보다 2배이상 속도로 샘플링해서 디지털 신호로 만들면, 다시 복원할 수 있다.

![image-20210202105609878](image-20210202105609878.png)

![image-20210202105900384](image-20210202105900384.png)

시간축을 초당 몇번 나눌꺼냐, 가청 주파수가 2만헤르츠? 초당 4만번 이상만 샘플링을 하면, 사람이 듣는 소리는 거의 다 샘플링할 수 있다.

![image-20210202110134528](image-20210202110134528.png)

아까 얘기한 대로 가청영역은 2만2천이면 충분, 그래서 두배로 샘플링. 초당 2바이트(16비트)로 저장. 오른쪽 왼쪽 양쪽채널을 두배로 저장. 74분짜리. ㅇㅇ. 초당이니까 60을 곱해서 단위 맞춰줌.

여튼간에, 

* 아날로그 신호를 디지털 신호로 변환해야 컴퓨터에서 써먹을 수 있다.
* 두배로 샘플링해야 다시 복원할 수 있다.
* 음질도 마찬가지이다. 아날로그 신호인 소리를 컴퓨터에서 재생하려면 디지털 신호로 만들어야 하고, 그러면 샘플링해서 끊어져있는 데이터의 연속으로 변환해야한다.

통신

보내려는 것, 파일이나 데이터를 잘개잘개 쪼개서 보낸다.

인터넷 역사

1982년, 미국의 대학들이 네트워크를 만들었음. 그리고 1982년, 전길남 박사님이 우리나라에 와서 연구해서 우리도 네트워크를 만듬. 그리고 성공함.

그러다 전 세계를 네트워크로 연결할 수 있겠다 싶었데. 그래서 학자들이 연구를 공개하고 그러다보니 다들 통신이 가능해짐.

통신도 여러가지가 필요. 받았는지 확인하는게 필요할 수 도 있고, 보안이 필요할 수도 있고, 통신이 엄청엄청 복잡해져갔다.

네트워크 토폴로지

종단 간 연결을 해주려는데 어떻게 해주는게 좋을까 연구하기 시작함

라인으로 할까? 트리로? 링으로? 아님 풀 커넥티드? 버스? 여러 방법이 나왔다.

어떤게 더 효율적이냐는 어떤 환경이냐에 따라 다르다.

그러다보니 주소가 필요해짐.

패킷스위칭

![image-20210202112300698](image-20210202112300698.png)

전화기는 내가 쓸때 다른사람이 못씀. 인터넷은? 내가 써도 다른사람이 쓸 수 있음. 회로가 고정되어 있지 않음. 라우터들이 연결되어 있고, 시간을 나눠서 회선을 씀. 인터넷회사들은 이걸 조정해줌.(요금제)

이렇게 수많은 라우터들이 IP프로토콜로 연결되어 있는 망을 인터넷이라고 한다.

같은 IP주소를 공유하는 사람들, 이 네트워크를 로컬 에리어 네트워크, LAN이라고 한다.

LAN에서 인터넷을 경유해서 목적지의 LAN까지 간 다음 대상 호스트에게 패킷을 보낼 수 있다.

TCP의 신뢰적인 통신은 어떻게 가능할까?

![image-20210202112805426](image-20210202112805426.png)

연결기반이고, 상대방이 받았는지 확인응답(ACK)을 받기 때문이다.

보냈는데, 보낸거에 대한 ACK가 안오면 실패로 간주하고 재전송한다.

그만큼 오버헤드가 크다. 보낸 데이터에 대해 모든 확인응답을 요구하기 때문이다.

![image-20210202113051711](image-20210202113051711.png)

아 유니, 멀티, 브로드캐스트 까먹었다. 다시 정리해보자

유니캐스트. 대상지정, 한명한테 쏨

UDP는 멀티, 브로드캐스트 가능. 한번에 여러명한테 보낼 수 있음

IP와 포트에 대해 정리해보자

프로토콜들에 헤더가 있는 이유는, 스트림에서 어디부터 어디까지가 중요한 의미가 있는지 알기 위해서.

내가 이 헤더를 시작해서, 어디까지가 보내는 데이터의 끝인지 알기 위해서.

MTU. TCP에서 데이터를 보내는 크기? 패킷을 나눠 보내는 단위? 1400바이트보다 작은걸 보내면 ㄱㅊ지만, 길면 짤려서 보낸다. 그래서 이게 필요함.

끝날땐 4way핸드쉐이크를 해야 함

![image-20210202113848657](image-20210202113848657.png)



tracert는 라우터 경로를 추적할 수 있는 명령어

nslookup은 네임서버한테 입력한 도메인이름의 주소를 알려달라고 요청하는 명령어

소켓

통신하기 위해 필요한 소프트웨어적인 도구. 통신수단.

http는 요청메세지와 응답메세지가 있다.

읽기 편할려고, 라인마다 \r\n과 같은 특수문자를 넣어두었다. 그러면 읽기 편하게 개행되니까

GET공백url공백버전

url에는 경로가 들어감. / 라던가. 그런거. 서버에서의 경로. 이거에 맞춰서 요청을 보내야 한다

요청한 경로에 리소스가 있으면 응답해준다.

클라이언트

식당에 간다. 주문받는 서버가 있고, 고객인 클라가 요청한다. 서버는 요청을 받고, 그 처리결과를 클라에게 준다. 웹서버도 이런 식.

원래 http는 http요청하고 응답받는 이 과정마다 연결이 끊어졌음(TCP). 근데 이것도 발전해서 안끊어지고 계속 통신할 수 있게 됨.

정규표현식

request, response도 그렇고, 한줄로 된 텍스트 메세지랑 비슷함. 어디까지가 get, url, version인가? 정규표현식을 쓰는 경우가 많다. 

![image-20210202120352689](image-20210202120352689.png)

정규표현식을 이용해서 받은 값을 읽어서 처리할 수 있다.

![image-20210202120448011](image-20210202120448011.png)

이렇게하면 이름으로 매칭되는걸 찾을 수 있다.

우리가 정규표현식 안만들어도, 대부분의 표현식은 메세지를 뜯어서 처리해주는 라이브러리가 있다. 보통.

워낙 많이 쓰여서 그렇다.

다만 그게 어떤식으로 동작하는지 배워보고 싶어서 하고있는 것 뿐이다.

HTTP1의 단점. 연결하고 요청하고 응답받으면 연결 해제함. 너무 잦은 연결수립과 해제의 오버헤드. 이게 싫다

그래서 나온게 HTTP2. 커넥션 한번 하는 동안에 여러번 받아올 수 있다.

심지어 HTTP/3방식도 논의되는 중. QUIC로 통신하기도 한다. UDP를 쓴다나?

프로그래밍 관점

비동기 처리

클록. 주기적으로 발생하는 신호. 클록의 주기. 한번 사이클을 돌때의 클록의 주기. 그 주기가 초당 몇번 일어나는지. Hz. 초당 한번이 1Hz. 초당 두번이 2Hz. 컴퓨터의 모든 장치는 클록에 맞춰서 동작한다. CPU도 마찬가지.

동기방식은 클록에 맞춰서 동작된다.이런걸 동기 방식.

![image-20210202121453422](image-20210202121453422.png)

타이밍이 맞을때까지 기다리는걸 말함. 누가 누구와 맞을때까지 기다리는걸 동기화라고 한다. area수행하다가 distance를 만나면 그 함수를 처리한 다음 그 결과가 리턴되어 dx에 저장됨. area함수는 요청에 대한 응답이 올때까지 기다리는 것. 그래서 area함수는 타이밍이 맞을때까지, distance함수가 값을 리턴할때까지 기다린다.

간접참조-서브루틴?

예전에는 하나의 루틴으로 실행됨. 그러다 서브루틴이 생김. area처리하다가, distance라는 함수를 처리하고 돌아오는 , distance라는 서브루틴을 처리하고 오는 것. 이때, 서브루틴이 완료될때까지 기다린다. 동기적으로 ㅇㅇ.

비동기는?  서브루틴을 실행시킴. 나중에 이 서브루틴이 다 완료되면 그때가서 완료를 알림. 보통 완료되면, 지정된 콜백함수를 실행시켜서 완료에 대한 처리를 함. 콜러 루틴은 서브루틴의 완료를 기다리지 않고 자기 일을 함. 여하튼 콜백함수는 클로저함수로 대체할 수 있음.근데 서브루틴도 콜백함수나 클로저함수를 실행하면 블록됨.콜백함수나 클로저의 완료가 끝나길 기다리기 때문임.

패러럴과 컨커런트

컨커런트는 시간을 쪼개서 번갈아가면서 수행하는 것. 그래서 사람이 보기엔 동시에 수행되는것처럼 보임

패러럴은 진짜로 동시에 수행되는것(하드웨어에 의해. 멀티코어.)

순차적인 동기작업 = 1 2 3 4 5

일꾼이 여러명. 동시에 다 나를 수 있음. 물리적으로 워커가 여럿이면 좋지만, 아닌 경우도 있음.

스레드? 스레드를 만들다 보면, 더 효율적이지 않은 순간이 온다. 스레드 많이 만든다고 해서 병렬처리된다는 보장이 없다. 스레드를 많이 만들기 보다는, 논리적으로 여러 작업을 동시에  처리할 수 있는 환경을 만들려고 한다.

블로킹, 완료될때까지 대기. 논블로킹, 자주자주 확인, 대신 대기하지 않으니, 다른일을 처리할 수 있다.

근데 비동기도 비동기  요청해놓고 그 작업의 완료를 기다려버리면? 결국 블로킹임

콜백이나 클로저로 처리? 정확히는 완료를 콜러가 받는게 아님. 그냥 완료되면 넘겨줬던 콜백이나 클로저를 실행시키라는 것 뿐임. 그래서 사실 비동기에서 완료를 처리하는 루틴은 비동기처리하는 서브루틴이 된다. 콜러 루틴이 아니라.

그리고 워커는 대기하면 안됨. 그 동안 멈춰버리면 비동기로 요청하는 의미가 없다.

타이머?

주기적으로 실행하는 애

타이머한테 일을 시켜놓으면 타이머가 동작함. 얘도 전형적으로 다른 워커가 있어야 동작한다.

노드같은 애들도 이런게 같은 스레드에서 타임아웃되는 이벤트 루프 방식으로 처리되는 경우가 있어서 타이머마다 동작방식이 다르다.

네트워크 프로그래밍을 하려면, 메인스레드가 요청을 담당하는 경우가 있고?? 엥????

여튼 개념상 메인스레드가 계속 요청을 하면 네트워크 스레드가 그걸 처리하고, 완료되면 메인스레드가 넘겨준 코드를 실행하도록 되어있다.

코루틴? 이걸 주고받는게 아니라, 요기조금 실행하고 요기조금 실행하고, 진짜 루틴자체가 동시에 실행되는 뭐 그런것도 있다.

브라우저에 뭘 치면 어떻게 동작해서 접속하는지 설명해봐라. nslookup의 동작과정을 설명해봐라.

인터뷰때 이런거 막 물어본다고... 잘 대답할 수 있도록 준비하자.

마르코프체인과 바에시안? Markov Chain, Bayesian?

소켓은? 전송계층에 있는걸 응용계층에 연결해준 것.

URL과 URI는 표준의 차이. 개념을 확장한 것. 포괄하는 개념.  URI가 URL을 포괄함

컨텐츠 길이가 있어야 표준을 지킨 것이다.

도메인은 이름의 형태를 나누는 방식을 DNS(시스템)라고 함. www google 이런거가 도메인, www.google.com 이렇게 된게 호스트 네임

서버 하나가 여러 IP를 가지면 서버를 분산해서 처리하게 할 수 있음.

컨텐츠 협상. 보통은 에이전트를 보고 매핑을 해주거나 하는데, 컨텐츠를 맞춰주고 싶은 경우, 헤더에 어떤게 들어있냐에 따라 다른걸 주기도 한다. 이런걸 이제 에이전트가 뭔지 보고 맞추거나 함. 너무 깊게 보지 말 것. 리퀘스트, 경로, 그다음에 맨 윗줄이 중요. 그 다음 헤더는 덜 중요. 컨텐츠협상은 헤더값 가지고 구체적인 무언가를 설정하는 것임. 리퀘스트랑 패스에 있는걸 공부하고 점진적으로 공부해라

로컬 도메인서버는 인터넷 망마다. 회사마다 있다. 지역에 국가마다 국가도메인별로 있고 전세계도메인 관리하는게 따로 있다

URI는 나중에 만든 표준. 요즘 둘 다 구분 없이 쓰긴 하는데 URI가 나중에 포괄해서 만든것

www를 붙여도 요청할때마다 달라질 수 있고, 그래서 IP가 다를 수 있음. 붙였느냐 아니냐에 따라 서버가 다를 수 있다.

Request하고 나서 프로그램에서 끊어줘야 함. close()

# 코딩일일결산

#### 내일의 나에게 보내는 전달사항

* 월요일에 배운 내용 정리하기
* 토끼책이랑 코플듣기
* 유닉스의 탄생이란 책이 재밌다는데, 한번 찾아보자

#### GOOD

* 

#### BAD

* 

 

