---
sort: 8
title: 알고리즘 기초 : 브루트 포스
tags: [ 알고리즘, 백준 ]
---

## CodePlus 알고리즘 : 브루트 포스

* 가능한 모든 경우의 수를 다 시도해보는 방법을 브루트 포스라고 한다.
* 자물쇠의 비밀번호가 될 수 있는 모든 경우를 다 입력해서 열면, 브루트 포스 방식으로 따는 것이다.
* 모든 경우의 수를 다 시도해보는거라서 모든 문제를 풀 수 없다. 너무 오래걸린다면, 그건 못푸는것이다.

### 브루트 포스로 문제푸는 단계

* 사람이 직접 문제의 모든 경우의 수를 계산해본다. 계산해보고, 브루트포스로 풀 수 있을지 말지를 판단하자.
* 모든 경우의 수를 만들어낸다.
* 만들어낸 경우의 수로 문제를 풀어본다.

모든 경우의 수를 만들어내는 방법은 여러가지가 있다.

* for문 사용
* 순열 사용
* 재귀호출 사용
* 비트마스크 사용

아저씨 말로는 재귀호출쓰면 웬만한건 다 된다고 한다.

시간복잡도는 O(경우의 수 * 방법 하나당 걸리는 시간)이라고 한다.

### 경우의 수

* n명의 사람이 한줄로 선다면, `n * (n-1) * (n-2) * ... * 1`이 된다.
  * 한명 세우고, 세운 한명 제외하고 세우는 식이라, 결과적으로 `n!`이 된다.
  * `n!`의 경우, `11!`만 되도 1억에 근접한다. 이때 경우당 문제푸는 시간이 n이라도 된다면 `n*n!`이라서, 거의 풀 수 없게 된다.
  * 보통 `n!`이면 `n <= 10`이라고 한다.
* n명의 사람 중에서 대표 두명을 뽑는다면, `nC2`로 표현할 수 있다. 세명이라면 `nC3`이다.
  * 각각 `n(n-1)/2!`, `n(n-1)(n-2)/3!`이라서, 각각 `O(N^2)` `O(N^3)`이다.
* N명의 사람이 있을 때, 각 사람이 영화를 볼지 말지를 결정할 때, 가능한 조합의 수
  * 각각 볼 수 있고 안볼 수 있으므로, 명당 경우의 수는 2이다. n명있다면 2^n이다.
  * 그래서 `O(2^n)`이 된다.
  * `2^20`이면 `1048576`이 되어서 보통 `2^n`이면 n 제한은 20이라고 한다. 물론 절대적인건 아니다.
* 요점은, 문제를 풀 때, 모든 경우의 수에 대해 문제를 풀면 `O()`가 얼마인지 계산해보고, 브루트 포스를 쓸 수 있는지 아닌지를 판단하고 적용하라는 것이다.

### 재귀호출

* N개중 M개를 뽑는 문제에서 순서가 중요하면 재귀호출을 쓸 수 있다고 하신다.
* 선택과 관련된 문제도 재귀호출을 쓰면 된다고 하신다
* N, N-1, N-2가지 ... 이런식이면 순서가 필요하고 그러면 N!이 된다고 하신다
* 선택은 N가지 중 일부를 선택하거나 하지 않는 조건이 있는 경우라고 한다? 그래서 2^n이라고 하신다.
* 직접 풀어봐야 이해할 것 같다.

#### N과 M(1) boj 15649

* 재귀함수로 어떤 위치에 올 수 있는 수를 결정한다
* 각각의 재귀호출에서 어떤 위치는 바뀌어야 한다. 안그러면 항상 같은 값이 나오니까 바꿔야 한다.
* 그 외에 내가 어떤 위치를 방문했는지 등의 정보를 유지할 필요가 있다.
* 이런건 배열로 처리하면 된다. 근데 배열은 0부터 시작하니까, 그냥 0번째를 낭비하는 방법도 문제풀때는 나쁘지 않은 것 같다.
* 배열로 방문여부를 따지거나, 수열을 만드는 작업은 까다로울 수 있다. 문제 많이 풀어서 익숙해져야 하겠다.
* 아직은 익숙하지 않다. 더 연습하자.

### NM과 K(1) boj 18290

* N X M 배열에서 K개의 셀을 선택하는 문제이다.
* 그래서 nmCk이다.
* N X M 배열인 만큼, visit배열도 2차원으로 하면 된다.