---
sort: 2
title: 객체지향 프로그래밍 공부한 내용 정리
tags: [ OOP ]
---

### 객체지향의 사실과 오해를 더 읽고 기록으로 남겼다.

* [책 읽고 정리하는 페이지](https://malloc72p.github.io/posts/Book/The_essence_of_object_orientation/chapter-1.html)

프로그램은 매우 복잡하다. 단순한 기능마저도 복잡하다. 그래서 이걸 작은 책임으로 나누어서 작은 객체들에게 나누어준다. 이 객체들은 메세지를 주고 받으면서 협력해서 복잡한 문제를 해결한다.

객체는 잘 협력해야 하며, 자율성을 가져야 한다. 누군가가 시켜서, 시키는대로 하는게 아닌, 자신의 방법대로 자신의 책임을 다할 수 있어야 한다. 

객체에게 어떤 일을 해달라고 할 때, 메세지를 보내서 요청한다. 객체는 이 메세지를 받고, 자신이 이해할 수 있는지 판단한 다음, 자신의 메서드로 이 요청을 수행한다. 이처럼 메세지와 메서드를 분리해서 객체의 자율성을 높였다고 책에 써있는데, 사실 난 이 부분은 잘 이해되지 않는다. 뭔가 이해가 되는 것 같으면서 안되는 느낌이다.

객체는 어떤 행동을 하기 위한 상태를 가져야 한다. 이 상태가 없다면 행동을 할 수 없다. 책에선 예전의 개발 방법론에선 데이터와 프로시저를 구분했으나, 객체지향에선 데이터와 프로시저를 객체로 묶어서 표현한다고 하는데, 이 부분도 잘 이해가 가지 않는다. 데이터가 상태이고, 프로시저가 행동인걸까? 좀 더 읽어봐야겠다.

### 객체지향 프로그래밍 학습정리

#### 클래스와 오브젝트, 인스턴스에 대한 정의를 나름대로 정리

소프트웨어에 구현하고자 하는 대상을 오브젝트(객체)라고 한다. 이 오브젝트를 구현하기 위해 만든 설계도를 클래스라고 하며, 이 설계도(클래스)대로 만들어서 메모리에 올린 실체를 인스턴스라고 한다.

#### 상속과 다형성에 대해 학습하고 정리한다. 

상속 
Su-47이나 Su-37이나 형태나 스펙은 다르지만, 일단은 비행기다. 연료상태가 있고, "날 수 있다"라는 공통된 행동이 있다. 이러한 여러 사물들로부터 공통된 속성과 행동을 추출해서 하나의 클래스로 만들 수 있다. 예를들면 Airplane으로 하겠다. Airplane클래스엔 공통된 속성과 행동인 fuelState랑 fly()를 정의한다. 그런 다음 이걸 Su47클래스랑 Su37클래스에 상속해주면 똑같은 코드를 각각의 클래스에 작성하지 않고, Airplane클래스의 코드를 재사용할 수있다.

다형성 
서로 다른 객체가 같은 메세지를 받았을때, 각자의 방식으로 메세지를 처리하는걸 다형성이라고 한다.

#### this(또는 self)와 super 키워드 차이점에 대해 정리한다.

this
클래스가 인스턴스화 되었을 때, 자기 자신을 가리키는 키워드를 this라고 한다.
super
어떤 상위클래스를 상속받은 하위클래스가 인스턴스로 생성되면, 상위클래스도 인스턴스로 생성되어야 한다. 이를 위해서 하위 클래스의 생성자의 맨 앞에 super()를 통해 상위 클래스의 생성자를 호출해야 한다. 또한 super키워드를 이용해서 상위클래스의 인스턴스에 접근할 수 있다. 다만 public이나 protected 접근제어지시자로 선언된 변수와 메서드에만 접근할 수 있다. 만약 상위클래스와 하위클래스에 같은 이름으로 선언된 메서드의 경우, super나 this 키워드로 구분해서 호출할 수 있다.

#### 객체 인스턴스 비교 방법에 대해 정리한다.

자바의 경우 equals메서드를 오버라이드해서 비교할 수 있다. 그냥 ==로 비교해버리면 두 인스턴스의 레퍼런스값만 비교해버린다. 이걸 원한거라면 괜찮겠지만, 그게 아니고 해당 객체의 어떤 비교방법을 써서 비교해야 한 거라면 문제가 된다. 이때, 이 클래스의 equals메서드를 오버라이드해서 어떤 비교방법을 여기에 정의하고, 두 인스턴스를 비교할 때 equals메서드로 비교하면, 원하는 방법으로 두 인스턴스를 비교할 수 있다.

#### SOLID 원칙에서 SRP 단일책임원칙에 대해 학습하고 정리한다.

객체는 단 하나의 책임만을 가져야 한다. 만약 그 객체가 변경된다면 이유는 단 하나, 그 책임에 대한 내용이 변경되었기 때문이다. 만약 다른 이유로 변경되었다면, 그 객체는 단 하나의 책임만을 가지고 있지 않았다는 말이 된다. 

```java
class Rectangle {
  public void display(){}
}
```

여기서 display의 결과가 도형을 좌표계에 출력하고, 그 크기도 출력한다고 생각하면, display는 좌표계에 도형을 출력하고, 크기도 출력하는 두가지 책임을 지니고 있는거라 SRP에 어긋난다. 만약 누가 도형만 출력하고 싶다던가, 크기만 출력하고 싶다던가 하면, display메서드의 기능을 바꾸던가 아니면 중복되는 기능을 가지는 메서드를 두개 더 만들거나 해야 한다. 그러니 처음부터 이렇게 하면 된다

```java
class Rectangle {
  public void displayShape(){}
  public void displaySize(){}
}
```

이러면 각각의 메서드는 도형을 출력하거나 크기를 출력하는 단 하나의 책임만 생기기 때문에, 어떤 메서드가 변경되어도, 다른 곳에 주는 영향이 작아진다는 장점이 있다.

#### SOLID 원칙에서 OCP 열림-닫힘원칙에 대해 학습하고 정리한다.

기존의 클래스나 메서드를 수정하지 않도록 하면서, 확장은 할 수 있게 프로그램을 작성하라는 원칙이다.
만약 도형을 출력하는 코드가 아래와 같이 되어있다고 치자.

```java
display(Shape s){
   if ( s instanceof Rectangle) 
       /*print Rectangle*/
   else if ( s instanceof Triangle) 
       /*print Triangle*/
}
```

이런 상태에서 팔각형이 추가된다면?
기존의 display메서드를 수정해야 한다. 근데 이 수정과정에서 문제가 생겨버린다면?
Rectangle이나 Triangle등, 기존에 잘 돌아가던 코드에도 문제가 생긴다.
그러니 이렇게 안하고, 아래처럼 하면 개방 폐쇄의 원칙을 지킬 수 있다.

```java
class Rectangle extends Shape{
   display(){/*print Rectangle*/}
}
class Triangle extends Shape{
   display(){/*print Triangle*/}
}
class Octagon extends Shape{
   display(){/*print octagon*/}
}
Shape s = new Octagon();
s.display();
```


이렇게 기존 코드를 건드리지 않고 기능을 추가할 수 있다.

#### SOLID 원칙에서 LSP 리스코프교환원칙 대해 학습하고 정리한다.

자식클래스는 최소한, 부모클래스가 쓰이는 곳에서 쓰일 수 있어야 한다는 원칙.
위의 예제에서 s.display()를 하는게 그 예이다. 어떠한 도형클래스의 인스턴스가 오더라도, s.display()에선 도형을 출력하는 기능을 수행할 수 있다. 그러니 이건 LSP를 지킨다고 볼 수 있다.
그럼 못지키는 경우를 보자. 

```java
GameWorld{
     Tile[][] tilemap;
     getTileInfo(int x, int y);
     /*수많은 유용한 기능들*/
}
class My3DGameWorld extends GameWorld{
   Tile[][][] myTileMap;
   getTileInfo(int x, int y, int z);
}
```

GameWorld라는 클래스는 게임월드데이터 정보를 갖고 있다. 여기에 쓸만한 기능이 많아서, 이걸 재사용하면 좋겠다 싶어서 내 월드데이터 클래스에 상속시켰다.
문제는 내 월드데이터는 3D데이터이다. 일단 첫번째로, 2D게임의 기능들을 상속받았으니, 아무것도 못쓰겠다. 근데 이건 이거고, LSP를 어떻게 못지키는지 보자.
자식클래스는 최소한 부모클래스가 쓰이는 곳에서 쓰일 수 있어야 한다고 했다.
부모클래스가 이렇게 쓰이고 있었다면?

```java
GameWorld world = new GameWorld();
world.getTileInfo( 42, 42 ).remove();
```

그러면 여기서 자식클래스도 쓰일 수 있을까? 당연히 3D게임인지라 쓰일 수 없다. 얘는 3차원 좌표계로 타일을 찾아야 하는데, 이렇게는 쓸 수 없다. 따라서 이 상속구조는 잘못되었다는걸 알 수 있다. 따라서 LSP 원칙을 지키면 이런 잘못된 상속구조를 피할 수 있다.