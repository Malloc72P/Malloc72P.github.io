---
sort: -17
title: TIL-17, 열일곱번째.
tags: [ TIL, 운영체제 ]
---

# 오늘 할 일

- [x] 운영체제의 역할에 대해 다시 정리해보기
- [x] 멀티프로그래밍 시스템과 시분할 시스템에 대해서 다시 정리해보기
- [x] 프로세스와 스레드에 대해 다시 정리해보기
- [x] 멀티 프로그래밍, 프로세싱, 태스킹, 스레딩
- [x] 프로세스와 스레드 생성에 대해 정리하기
- [x] 스레드를 사용할때의 이점을 정리해보기.
- [ ] ~~폰노이만구조랑 하버드구조 정리. 아니 또 안했다고??~~

# 오늘 배운 내용  
어제 정리한 내용이랑 오늘 공부한 내용을 가지고 다시 정리해본다.

## 운영체제의 역할

운영체제는 사용자가 컴퓨터를 편리하고, 효율적이고 안전하게 이용할 수 있도록 도와주어야 한다.

* 운영체제는 사용자에게 쉘과 같은 인터페이스를 제공해서, 편하게 작업을 요청하고, 처리결과를 볼 수 있게 해줘야 한다.
* 입출력장치, 프로세스, 메모리 등의 시스템 자원을 관리해야한다. 또 이러한 시스템 자원에 접근하는 알관성있고 안정성있는 인터페이스(시스템콜)를 제공해야 한다. 사용자가 직접 기능을 구현해서 하드웨어의 기능을 이용한다면, 일단 너무 어렵고 오래걸리는데다, 실수로 하드웨어를 망가뜨릴 수 있다. 그래서 운영체제는 시스템콜과 같은 인터페이스를 제공해서 이런 문제를 방지해야 한다.
* 운영체제는 보호, 보안 기능을 제공해야 한다. 직접 구현한 기능으로 하드웨어를 이용하다 망가뜨린다거나, 다른 프로세스의 메모리에 무단으로 접근해서 다른 사용자의 정보를 열람한다던가 하는 문제로부터 보호하고 막아주어야 한다.



## 멀티프로그래밍 시스템과 시분할 시스템

##### 멀티 프로그래밍 일괄처리 시스템

단일 프로그래밍 방식을 쓰면, 주메모리에 하나의 프로그램만 적재해서 수행한다. 그렇다 보니, 입출력 요청을 하고, 그 결과가 반환될때까지 CPU는 아무것도 안하고 놀게 된다. 문제는 CPU에 비해 입출력장치가 너무 느려서, CPU가 너무 오랫동안 놀게 된다는 것이다. 

반면 멀티프로그래밍은, 주메모리에 여러개의 프로그램을 적재해서 수행할 수 있다. 그리고 입출력 장치를 이용할 때, 입출력 요청만 하고, 그 결과를 기다리지 않는다. 대신 다른 프로그램을 수행한다. 나중에 입출력 작업이 완료되면, 인터럽트가 발생한다. 그러면 제어가 인터럽트 처리 프로그램으로 넘어가서, 입출력작업 완료에 대한 처리를 해줄 수 있다. 단일 프로그래밍과 다르게, 입출력을 하는 동안 다른 프로그램을 처리할 수 있으니 낭비되는 CPU시간이 줄어들고, 그만큼 효율적으로 CPU를 쓸 수 있다는 장점이 있다.

##### 시분할 시스템

CPU의 시간을 **타임퀀텀**이라는 단위로 아주 잘개 쪼갠다. 그리고 프로그램을 이 타임퀀텀만큼만 실행한 다음 다른 프로그램을 실행한다. 여러 프로그램을 **번갈아가면서 타임퀀텀만큼만 아주 짧게 실행**하는 것이다. 타임퀀텀은 **사람의 기준**에서는 **매우 짧은 시간**이라서, 여러 프로그램을 번갈아가며 실행해도 **응답속도가 빠르다**. 그렇다보니 여러 사람이 시분할시스템을 **공유해서 이용**해도, 응답시간이 빠르다보니 마치 컴퓨터를 **독점해서 쓰는 것 같이 느끼게 해준다.**



## 프로세스와 스레드

#### 프로세스

##### 프로세스의 등장배경

멀티프로그래밍 시스템과 시분할 시스템이 등장하면서, 주메모리에 여러개의 프로그램을 적재하고, 이들을 번갈아가면서 실행하게 되었다. 그러다보니, 프로그램들이 같은 공유자원을 쓰고 서로의 작업을 덮어써비리는 문제가 발생하거나, 잘못된 메모리접근으로 어떤 프로그램들이 다른 프로그램의 결과를 방해하거나, 서로 자원을 가진 상태로 서로의 자원이 풀리길 기다리는 교착상태 등 다양한 문제가 발생했다. 이에 따라 수행중인 프로그램의 상태를 감시하고 제어할 수 있는 방법이 필요했는데, 그래서 나온게 프로세스이다.

##### 프로세스의 정의와 구조.

프로세스는 **수행중인 프로그램**으로서, 프로그램의 인스턴스라고 할 수 있다. 프로세스의 **메모리 구조**는 이진 명령어가 저장된 텍스트영역, 전역변수의 영역인 **데이터** 영역, 동적할당된 메모리의 영역인 **힙**, 함수와 복귀주소의 영역인 스택영역이 있다. 또한 커널은 **PCB**라는 **자료구조**를 만들어서 **프로세스의 상태를 감시하고 제어**한다. **PCB**안에는 프로세스의 아이디, 사용한 cpu시간등 프로세스에 대한 다양한 정보가 있다. 그 중에서 **프로세스 컨택스트**라는 정보가 있는데, 여기엔 프로세스의 수행에 필요한 **상태 정보**(처리기 레지스터값 등등)가 보관된다. **프로세스 스위칭**이 발생해서 준비상태나 블록상태로 전이되는 경우, 그 당시의 **처리기 레지스터에 있던 정보를 PCB에 저장**한다. 나중에 다시 수행상태로 전이되어 **수행을 재개**하게 되면, PCB에 저장해놨던 레지스터 값들을  다시 **CPU레지스터에 저장**해서 수행을 이어서 할 수 있는 상태로 **복원**한다.



#### 스레드

##### 스레드의 정의와 구조

스레드는 프로세스 안에 있는 실행흐름이며, 디스패치의 단위이다. 그래서 스레드가 한개 있으면, 한순간에 하나의 코어에 의해서만 수행될 수 있다.

스레드는 실행흐름인 만큼, 수행을 하기 위해선 함수를 호출해야 해서 지역변수와 매개변수를 저장하고 복귀주소를 저장해야 한다. 그래서 각각의 스레드는 자신만의 스택을 가져야 한다. 다만 스레드는 프로세스 안에서 사는 존재라서, 프로세스의 스택을 이용한다. 만약 프로세스가 생성되어서 스레드를 하나 만든다면, 두 스레드는 같은 프로세스의 스택영역을 반으로 나눠서 쓰게 된다. 하지만 데이터 영역과 힙 영역은 공유해서 사용한다.

##### 유저레벨스레드와 커널레벨스레드

스레드는 유저레벨스레드(ULT)와 커널레벨스레드(KLT)로 나뉜다. ULT는 스레드 라이브러리에서 관리하는 스레드이고, KLT는 커널이 직접 관리하는 스레드이다. 그렇다보니 커널은 KLT의 존재는 알아도, ULT의 존재는 알지못한다. 

스레드 라이브러리가 ULT를 관리한다건, ULT의 제어가 사용자공간과 프로세스 내에서 이루어짐을 말한다. 스레드라이브러리로 제어가 넘어가서 ULT를 위한 자료구조가 만들어지고, 라이브러리에 있는 스케줄러를 써서 그 프로세스에서 준비상태에 있는 ULT로 제어를 넘겨서 실행시킨다. 

그렇다보니 커널은 이런 스레드가 있다는걸 모른다. 디스패치할때도 프로세스 단위로 한다. 커널이 보기엔 스레드가 하나만 있는 걸로 보이기 때문이다. 그렇다보니, ULT중 하나가 블록상태로 전이시키는 시스템콜을 하면, 그 프로세스 안의 죄없는 ULT도 다 같이 블록상태가 되는 것이다. 

그럼 ULT는 왜 쓸까? 일단 스레드를 관리하는데 시스템콜이 필요없다. 전부 사용자공간에서 이뤄지기 때문에, 스레드를 관리한다고 모드스위칭이 발생하지 않는다.  그만큼 오버헤드가 적다. 또한 스레드의 스케줄링이 스레드 라이브러리에 의해 이루어지기 때문에, 내 프로그램에 맞는 방법으로 스케줄링해서 최적화할 수 있다.

단점으로는 같은 프로세스에 있는 ULT가 블록을 유발하는 작업(대부분의 시스템 콜)을 하면, 그 안의 죄없는 다른 스레드도 다 같이 블록상태가 되버린다는 점이 있다. 그리고, 순수한 ULT기반의 스레드라이브러리를 쓰는 멀티 유저레벨 스레드 프로그램은 멀티코어의 장점을 살리기 어렵다. 커널은 모르는 스레드라서 따로 디스패치되지 못하고, 결국 그 프로세스 단위로 디스패치된다. 결국 코어가 여러개 있어도 한 시점에 하나의 ULT만 처리된다. 그래서 멀티 프로세싱의 장점을 살리기 힘들다.



### 멀티 프로그래밍, 프로세싱, 태스킹, 스레딩

#### 멀티 프로그래밍

여러 프로세스를 번갈아가면서 수행되는 인터리빙 방식으로 동작하는 방식을 말한다. 번갈아 가면서 수행하는거지 동시에 여러 프로세스를 수행하는건 아니다. 그래서 병렬처리(Parallel Processing)이라고 할 수 없다. 

멀티프로그래밍 개념에서 말하고자 하는건, 단일 프로그래밍에서 저지른 CPU시간낭비를 최소화하는 것이다.

#### 멀티 프로세싱

여러개의 CPU가 여러 프로세스를 병렬로 수행하는것을 말한다. 얘는 동시에 여러 프로세스를 수행할 수 있다. 

멀티프로세싱 개념에서 중요한 건, 여러개의 프로세스가 각자 여러개의 CPU로 디스패치되어 병렬로(동시에) 수행될 수 있다는 점이다.

#### 멀티태스킹 [출처](https://velog.io/@chy0428/OS-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1)

어떤 일을 수행하기 위한 명령어 집합을 태스크라고 한다. CPU스케줄러에 의해 태스크를 번갈아가면서 수행하는것을 멀티태스킹이라고 한다.

#### 멀티스레딩

병렬처리를 위해 하나의 프로세스 안에 여러개의 스레드를 만들어서 처리하는 방법을 말한다. 스레드 대신 프로세스를 여러개 만들어서 처리하면 멀티프로세스(프로세싱아님)라고 한다.

멀티스레딩은 멀티프로세스보다 컨택스트 스위칭이 빠르다. 근데 컨택스트스위칭은 프로그램이 실행되면서 빈번하게 계속 발생한다. 그래서 컨택스트 스위칭이 프로세스보다 빠르다는 장점은, 멀티스레드가 멀티프로세스보다 나은 성능을 내는데 도움을 준다.

또한 스레드는 스택만 별도로 갖지, 힙과 데이터영역은 공유한다. 스레드 간 협력을 위해 데이터를 주고받거나 공유자원을 쓰는 경우, 간편하고 빠르게 힙이나 데이터 영역을 이용해서 통신하면 된다. 반면 멀티프로세스 방식으로 하면 이게 안된다. 각각의 프로세스는 분리된 메모리 영역을 갖기 때문에, 함부로 서로의 메모리에 접근할 수 없다. 그래서 프로세스 간 통신기법인 IPC(Inter process Communication)을 써야 한다. 물론 힙과 데이터영역으로 통신하는것보다 불편하다.  



## 프로세스와 스레드의 생성.

프로세스는 fork라는 시스템콜을 써서 자식 프로세스를 만들 수 있다. 자식 프로세스는 다음과 같은 특징이 있다.

* 부모의 텍스트영역 공유
* 데이터, 스택영역 복사
* 새로운 pid와 ppid를 가진다.
* open된 파일에 대한 정보를 공유한다. 각자 파일 디스크럽터 테이블은 따로 갖지만 같은 파일을 가리킨다.

exec시스템콜을 쓰면 프로세스 기존의 이미지를 무시하고 새로운 프로세스 이미지를 읽어와서 초기화하고 수행한다. 이걸 다시 말하면, 현재의 텍스트, 데이터, 스택 영역의 내용을 새로운 이미지로 대체하겠다는 것이다. 이걸 서서 새로 생성한 자식 프로세스에게 다른 일을 시킬 수 있다.

스레드는 pthread라는 모든 유닉스계열 POSIX시스템에서 쓸 수 있는 표준 API이다. 이 API를 써서 스레드를 쓸 수 있다. 스레드는 프로세스의 데이터와 힙 영역을 공유한다. 스택은 각자 가진다.



## 스레드를 써서 얻을 수 있는 이점

##### 병렬처리 프로그램을 작성할 때 스레드를 쓰면 좋다.

스레드는 프로세스에 비해 비교적 작은 자료구조만 업데이트해서 생성할 수 있다.

프로세스보다 컨택스트 스위칭이 빠르다. 비교적 작은 자료구조만 가지기 때문이다.

프로세스로 병렬처리를 하는 경우, 이들간에 통신을 하려면 IPC를 써야만 가능하다. 반면 스레드는 그냥 데이터나 힙 영역을 가지고 통신할 수 있어서, 스레드 간 쉽게 협업할 수 있다.



## 학습정리

##### 멀티 스레드 스케줄링 방식에 대해 학습하고 정리 :  [출처](https://coding-factory.tistory.com/569)

스레드 스케줄링 : 멀티스레드의 순서를 정하는 것을 말한다.
우선순위 방식 : 우선순위가 높은 스레드가 더 많이 실행되도록 스케줄링하는 것을 말한다.
순환 할당 방식 : 시간할당량(time slice)를 정해서 하나의 스레드를 정해진 시간만큼 실행하고 다시 다른 스레드를 실행하는 방식이다.

##### 스레드를 무제한으로 만들수 없다면, 프로세스가 많아질 때 성능 향상을 할 수 있는 방법이 무엇일까

ㄹㅇ루다가. 뭘까?

1. 코어수가 더 많고 처리속도가 더 빠른 CPU로 업그레이드한다?
2. 주메모리를 추가로 장착해서 더 많은 프로세스가 suspended되지 않고 수행될 수 있게 한다?

이건 아닌것같은디...

##### setTimeout 내부 동작 방식에 대해 학습하고 정리

js는 싱글스레드로 동작한다. 어떤 블록이 끝나면 큐에서 대기하는 처리가 있는지 확인하고, 있으면 처리한다. 이 덕분에 setTimeOut으로 10초있다가 이 함수를 처리하게 시켜도, 10초동안 다른 작업을 처리할 수 있는 것이다. 만약 10초가 지났는지 busy waiting하면서 검사했으면 다른 작업을 처리하지 못했을 것이다. 

##### 플랫폼에서 정확도 높은 타이머Timer를 구현하기 위한 방법은?

ㄹㅇ 이것도 뭘까? 잘 모르겠지만...

별도의 타이머 리스트와 스레드를 만들고, 타이머스레드가 끊임없이 타이머리스트를 검사한다. 시간이 만료된 타이머가 있으면 꺼내서 처리한다.
타이머 리스트의 요소는 Runnable인터페이스로 구현된 객체를 쓰면 될 것 같다. 타이머가 만료되면 꺼내서 run()메서드를 호출해서 처리하면 될 것 같다.

##### 멀티 스레드가 공용 리소스에 접근할 때 임계구역을 다루는 방식에 대해 학습하고, 어떤 경우에 사용해야 하는가?

뮤텍스

뮤텍스를 쓰면 한 순간에 하나의 스레드만 공유자원에 접근해서 쓸 수 있게 해준다. 뮤텍스로 보호된 영역을 임계영역이라고 부르는데, 이 영역은 크면 클수록 병렬성을 저하시키기 때문에, 필요한 만큼 최소화하는게 좋다.

세마포어

뮤텍스와 다르게 세마포어는 임계영역에 여러개의 스레드가 접근할 수 있게 통제할 수 있다. 세마포어는 정수값을 가지고 이걸 가지고 임계영역에 들여보낼지 말지를 판단한다. wait할때마다 -1하고, signal할때마다 +1해준다. 0일때 wait하면, 그 스레드는 블로킹되어, 나중에 누가 signal해줘야 깨어나서 임계영역에 접근할 수 있다. 

언제 써야 하는가

여러 스레드가 공유자원에 동시접근하는 경우, 서로가 서로의 작업을 덮어쓸 수 있다. 예를들면, 스레드A가 분명히 어떤 값으로 업데이트했다고 치자. 그런데 다른 스레드B가 업데이트 이전값을 가져갔던 상황이고, 그걸로 작업했단다. 그리고 A가 업데이트한 다음에 B가 업데이트했다면? A의 작업은 없던일이 되버린다.
이런식의 문제때문에 공유자원에 대한 접근을 통제해주어야 한다. 

***

# 코딩일일결산

#### 내일의 나에게 보내는 전달사항

* TIL에 흩어져서 정리된 내용들 다 카테고리로 분류해서 정리할 것.
* ~~폰노이만구조랑 하버드구조 정리. 아니 또 안했다고??~~

#### GOOD

* 오늘은 잘한게 없다

#### BAD

* 수업 끝나고 기절해서 제때에 TIL을 올리지 못했다...

* 뭔가 정리하는게 끔찍한 재귀호출의 지옥에 갇히는 기분이다. 이거정리하면 저거해야할 거같고, 하고나면 또 정리하고싶은게 생기고 또 생기고 ...... 마스터가 말한것처럼 원래 방향으로 돌아오는 능력이 필요한 것 같은데 잘 안된다.
