객지 공부, 깃 공부.

자바 공부.

3주 뒤엔 프로젝트 스프링이 있구, 웹서버가 있다.

각각 그때가서 배우면 된다



디자인 패턴 ㄴㄴ해

끝날때까지 학습 ㄴㄴ해

이유는 어설프게 공부해서 이상하게 적용하면 코드만 이상해진다.

고수가 되었을 때 공부해서 적용하려고 해볼 것.



깃 피알 일주일 최대 두번

많이 할 필요 자체가 없다.



커밋은 메서드 하나정도가 적당한 것 같구요

커밋 여러개 있어도 되구요

커밋 메세지 한줄로 요약할 수 있으면 좋네요

쪼갤 수 있었으니까요. 한줄이면 좋겠어요



깃?

분산 버전 관리 시스템

소스 코드 관리를 쉽게 해준다.

왜쓸까? 

* 버전관리
* 협업

토발즈 아조씨가 만들었다



깃에서 가장 중요한건 커밋

스냅샷. 정확하게는, 내 작업 디렉토리(워킹 디렉토리)의 스냅샷이다.

게임으로 치면, 세이브 포인트. 그래서 언제든지 커밋을 하고 나면 그 시점으로 돌아갈 수 있다.

깃은 변경사항을 저장하지 않고, 매번 파일 전체를 저장한다.



워킹트리 : 우리가 작업하는 공간. 깃의 입장에서는 여기가 샌드박스이다?

놀이터? 커밋이 깃의 저장소, 우리가 작업하는 곳은 워킹트리인데, 깃 입장에선 커밋을 만드는게 목표라서, 중요한걸  스테이지에 쌓았다가 커밋한다?

스테이지? 여기가 커밋을 준비하는 공간. 작업내용을 스테이징 하는 곳. 커밋할거라고 표시하는 곳

git init을 하면, 현 디렉토리가 작업 디렉토리가 된다

기본 브랜치는 마스터가 된다.

작업을 하면, 스테이지에는 아무것도 없다.

로컬저장소? 내 컴퓨터가 로컬 저장소라고 많은 사람들이 생각한다. 근데 아니다

.git폴더가 로컬 저장소이고, 그 밖의 공간은 워킹디렉토리이다. 깃 폴더에는 스냅샷들이 모여있어서 로컬저장소라고 한다.

커밋 대상 지정이 가능한가? 불가능하다. 커밋은 스테이지에 올라온 내용으로 커밋할 뿐, 커밋대상을 지정할 수 는 없다.

다만 어떤 파일을 스테이지에 올릴지는 결정할 수 있다.

원격저장소는 로컬 저장소를 서버에 복사해놓은 것이다.

브랜치는 작업의 흐름을 제어하기 위해 사용하는 것이다. 근데 얘는 사실 커밋에 대한 참조일 뿐이다. 커밋은 이전 커밋을 가리키고 있기 때문에, 브랜치가 그냥 참조이기만 해도, 각 브랜치에서 커밋 히스토리 흐름이 다르게 이어져서 보일 수 있다. 부모 커밋에 대한 링크가 있기 때문이다.

여하튼, 브랜치는 작업의 흐름을 제어하기 위해 있는 것이고, 브랜치 자체는 커밋에 대한 참조일 뿐이다.

태그는 커밋의 또다른 참조. 이름과 주석을 붙여서 버전관리에 쓸 수 있다,

커밋할땐 메세지를 최대한 자세하게 적는다. 한줄 띄고.

3분이라도 쓴다.



마스터, 또는 메인 브랜치에서는 작업하지 않는다. 다른 브랜치를 따서, 작업을 하고, 그 다음 마스터에 병합시켜준다. 브랜치는 기능 기준으로 브랜치를 만든다.

이슈하나당 브랜치를 만드는것도 나쁘지 않다. 어차피 브랜치는 삭제한다. 병합 후엔 필요없다보니, 지운다.

깃의 명령어는 각자 공부해보자

클론 : 프로젝트 복사

init : 프로젝트 생성

add : 내 파일을 스테이지에 추가. 변경사항을 추가한다고 생각한다면, 그건 틀린 것. 파일을 스테이지에 추가한다.

commit은 스테이지에 올라가 있는걸 스냅샷으로 만드는것?

push는 로컬저장소의 내용을 원격저장소에 올리는것?

pull은 원격으로부터 가져와서 로컬저장소와 병합하는 것. fetch는 원격과 로컬 저장소를 동기화하는것. merge는 두 커밋을 합치는 것. pull은 fetch + merge이다.

브랜치는 브랜치 생성에 쓰임

체크아웃은 브랜치를 바꾸는 기능과 브랜치에서 파일의 변경내용을 꺼내올 때 쓸 수 있다. 그래서 이 체크아웃 명령이 너무 복잡해서 깃에서 쪼갰다. 작업중인 브랜치를 바꾸는건 switch, 여러 커밋에 저장된 파일을 꺼내는건 restore이다. 그래서 체크아웃보다는 위의 두개를 쓰는게 좋다

스위치는 작업중인 브랜치를 바꾸는 것. 헤드를 바꾸는 것.

리스토어는 저장된 파일을 꺼내는 것?

스태시는 임시저장 명령? 

브랜치를 바꾸기 전에 작업중인 내용을 임시저장하는게 스태시

저 그러면 커밋을 하면 로컬 저장소에 현재 작업 디렉토리의 스냅샷을 저장하는거구, 스위치를 하면 현재 작업디렉토리의 내용을 지정한 커밋의 스냅샷의 내용으로 바꾸는거예요? 

1 브랜치 만들어서 작업

풀리퀘 보낸다

리뷰어가 리뷰해줌

나는 이어서 브랜치따서 작업

머지커밋이 생김

이걸 가져와서 리베이스를 한다?



패스트포워드 : 내가 가는 길이 하나뿐일때? 병합이 없을 때? 단순히 브랜치 참조만 절루 간다?

3way커밋? 머지커밋이 ??? 부모가 둘?? 충돌??? 

리베이스는 비추? 리베이스는 원격으로 올라간거나 남과 협업할땐 쓰면안됨. 나 혼자할때는 괜찮음

병합은 새로운 머지커밋을 만들었음

리베이스는 내 커밋을 들어다가 다른 커밋에 붙여버린다?

그러면 패스트포워드가 가능하다. 그치만 매우 안좋다? 브랜치 관리전략이 워크플로우인데, 이렇게하면 어떻게 된건지 알기가 어렵다? 또한 충돌이 나면 문제가 생긴다???

충돌이 나서 잘 안된다? 그러면 충돌 해결은 머지가 쉬우니, 더럽더라도 머지가 낫다.



깃 리버트? 각 커밋을 캔슬하는 커밋?



여하튼 포크하면 내 로컬에 프로젝트가 생긴다

왜 그냥 클론하지 않는가?

그냥 클론하면 문제가 뭐냐면, 원격저장소에 브랜치가 너무 많다. 그래서 그냥 해도 상관은 없지만, 포크로 하면 깔끔하기 때문에 포크로 한다.

내 아이디 브랜치 하나만 땡겨오겠다는 것.

그럼 내 로컬에 내 이름의 브랜치 하나만 생긴다.

여튼 여기서 브랜치 하나 딴다. 

애드스테이지, 커밋해서 작업한다

이 상태에서 푸시를 한다면? 내 저장소, 내 브랜치가 내 원격저장소에 이렇게 추가되는 것.

이게 스텝1.

리뷰가 끝나면 내 브랜치에 병합?



리모트 애드 업스트림 명령? 코드스쿼드 저장소에 내 아이디 브랜치가 업스트림 저장소로 등록이 된다? 오리진은 내꺼, 업스트림은 코드스쿼드 저장소. 그러고 나면 깃 페치 명령으로 업스트림 일케하면 내것만 땡겨온다? 저장소 별칭 안지어주면? 깃 페치는 원격의 내용을 다 가져오라는 거라서, 다른사람들의 작업내용을 싹다 가져온다. 우리가 원하는건 우리것만 가져오는 것.

그리고 풀은 하지 않는게 좋다. 페치 더하기 머지가 풀이다. 여기서 머지하면? 엄청나게 더러워진다. 그래서 뭘 해야 한다? 리베이스를 해야 한다. 작업내용을 원격에서 가져온 내용에 붙이겠다. 근데 이러면 어떤 문제가 생길 수 있다? 충돌이 많이 날 수 있다. 이럴땐 머지를 해라.

이때 나는 충돌은? 과거의 나와 현재의 나의 충돌. 뭐가 중요하냐? 현재의 나를 우선한다. 과거의 나를 버린다. 강제로 무시하는 명령이 있는데, 이거 쓰면 편하다고 한다.

https://github.com/codesquad-members-2021/java-chess

지옥에서 온 깃