---
sort: -15
title: TIL-15, 열다섯번째.
tags: [ TIL, 프로그래머스 ]
---

## 오늘 할 일

- [x] 코테문제 풀기
- [ ] 객체지향의 사실과 오해를 읽고 정리하기


##### 시간부족으로 취소된 일 목록

- [ ] 없음

## 오늘 배운 내용  
### 프로그래머스에서 문제풀기

### 64061 크레인 인형뽑기

스트림 써서 풀어보고 싶었는데, 오히려 문제 난이도만 높이는 것 같다. 아니면 아직 익숙하지 않아서 그런 것 같다.

이 문제는 큐로 처리하면 된다. 문제의 입력을 알맞은 자료구조로 처리하고 하라는대로 시뮬레이션하면 풀린다. 다만 입력을 잘 이해하고 풀어야 한다. 난 여기서 실수해서 해맸다.

### 42849 모의고사

모듈로 연산을 쓰면 되는 문제이다. 출력할때 스트림을 쓰면 편하다.

가장 많이 맞춘 학생들의 인덱스를 담은 배열을 리턴하면 된다. 예전에는 ArrayList를 써서 풀었는데, 지금보니 스트림을 쓰면 정말 편하게 할 수 있다. 다만 좀 그런게, FP을 하면 순수함수의 조합으로 문제를 풀어야 하는데, 배열의 요소에 접근해서 값을 수정했다. 이 부분때문에 FP로 풀었다고는 말 할 수 없을 것 같다. 외부의 상태를 건드리는데 순수함수라고 볼 수 있을까? 뭐 그래도 스트림을 쓰면 가독성이 좋고, 빨리 짤 수 있다.

```java
final int highest = Arrays.stream(sumList).max().getAsInt();
return Stream.iterate(0, i->i+1)
    .limit(sumList.length)
    .filter(i->sumList[i] == highest)
    .mapToInt(i->i+1)
    .toArray();
```

스트림으로 최대값을 구하고, 필터링을 통해 최댓값이랑 같은 값을 가진 배열만 출력되게 한다.

그 다음, 스트림의 각 요소에 +1을 해준다. 0번학생은 없다. 1번학생부터니까 이렇게 해줘야 한다.

예전에 짠 코드를 보니까 어렵고 길게짜놨더라. 물론 스트림의 진짜 좋은점이 이런건 아니겠지만, 그래도 배운걸 써먹으니 기분만큼은 좋다. 

### 12930 이상한 문자 만들기

스트림 쓰면 편할 줄 알았는데 오히려 힘들었다. 아직 익숙하지 않은건지 그냥 예전에 하던대로 하는게 나은 것 같다. 어떻게든 스트림 써서 풀려고 고민하지 말고, 필요할때 쓰자. 그럴 필요 없으니까.

여하튼 이건 큐를 쓰면 편하다. 공백만나면 큐에 있는걸 다 비워버리는 식으로 풀면 된다.

### 42748 K번째 수

스트림을 이용하면 sorted()를 쓸 수 있는데, 이걸로 정렬한 다음 k 번째 수를 구하면 쉽다

처음 풀때는 forloop로 풀었는데, 파이프라인 하나로 풀릴 것 같아서 한번 해봤다.

```java
import java.util.Arrays;
class Solution {
    public int[] solution(int[] array, int[][] commands) {
        return Arrays.stream(commands)
        .map(cmd->Arrays.stream(Arrays.copyOfRange(array, cmd[0] - 1, cmd[1]))
                .sorted().skip(cmd[2]-1).findFirst().getAsInt())
        .mapToInt(i->i).toArray();
    }
}
```

1. 우선 커맨드 리스트를 스트림으로 바꾼다. 2차원 정수배열이니까, 1차원 정수배열 스트림이 된다.

2. 1차원 정수배열을 k번째 수로 매핑한다.

3. 정수배열의 0, 1번째를 이용해서 원본배열에서 지정된 범위를 복사한다음, 스트림으로 넘긴다

4. 스트림을 정렬한다. sorted() 메서드를 쓰면 된다.

5. k번째 전까지 스킵한다. skip()메서드를 쓰면 스트림의 앞부터 패러미터만큼 스킵한다.

6. 첫번째를 찾고 정수값으로 반환한다.

7. k번째 수들의 스트림을 int 스트림으로 변환한다. mapToInt가 이걸 해준다.

   사실 이게 잘 이해가 안된다. 앞의 map에서 정수형으로 매핑했는데 Object[]로 넘어와서 mapToInt를 해줘야 메서드 solution의 리턴타입과 맞아떨어진다. 안해주면 리턴타입이 다르다고 컴파일 에러가 발생한다.

   여하튼 일케 해준다음 toArray()로 정수배열로 변환해주고 리턴하면 끝난다.

근데 실제 문제 풀때는 절대 이렇게 안하는게 좋을 것 같다. 내 기준으로 보면, 저게 더 알아보기 힘들다.

아닌가...? 그냥 내가 FP에 익숙하지 않아서 그런가...?

```java
//이건 전체코드가 아니다. 길어서 일부만 복사했다.
for (int[] cmd : commands){
    int from = cmd[0];
    int to = cmd[1];
    int k = cmd[2];
    int[] tmpArr = new int[to - from + 1];
    for (int i = from-1, j = 0; i <= to-1; i++, j++) {
        tmpArr[j] = arr.get(i);
    }
    answer.add(Arrays.stream(tmpArr).sorted().toArray()[k-1]);
}
```

이런식으로 변수명에 의미를 두고 하나하나 선언해서 작성하는게 나는 더 좋다. cmd[0]-1이라던가 이런식으로 하면 자꾸 햇갈려서 풀기 힘들다.

### 코테문제 풀때 잊지 말아야 할 것

* 덤비지 말 것. 주어진 입력과 출력을 이해한 다음 알고리즘을 작성하자. 당연한 말인데 이걸 안 지킬때가 있다.

  근데 왜 나는 항상 덤벙대는걸까? 조심하자.

***

## 코딩일일결산

#### 내일의 나에게 보내는 전달사항

* 

#### GOOD

* 어제 하고싶었던 대로 스트림을 써서 코테문제를 풀었다. 실력이 늘었는지는 잘 모르겠다. 아닌 것 같다 ㅋㅋ.

#### BAD

* 
