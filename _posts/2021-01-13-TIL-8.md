---
layout: post
title: TIL-8, 여덟번째.
feature-img: "assets/img/feature-img/DSC00168.jpg"
thumbnail: "assets/img/thumbnails/feature-img/DSC00168.jpg"
tags: [ TIL, 알고리즘, 자료구조, CodePlus, Leet, 백준 ]
---

## 1.오늘의 컨디션
1. zzz.

***

## 2.오늘은 어땠을까
* **오늘 한 일 요약**  
  * Leet에서 코테문제를 풀었다.
  * 백준에서도 코테문제를 풀었다.
  * ArrayList에 대해 더 공부했다.
  * HashSet의 존재를 알게 되었다.
<br>
* **오늘 배운 내용**  
  * **Leet 에서 푼 문제 정리**
    * **문제1 two-sum**
      * [문제 링크](https://leetcode.com/problems/two-sum/)
      * 이중루프를 돌긴 하는데, 두번째 루프는 i+1부터 배열의 끝까지 루프를 돈다.
      * a + b나 b + a나 같기 때문에 두번째 루프는 i+1 이전의 요소를 볼 필요가 없다. 이미 검사해서 그렇다.
    * **문제2 reverse-integer**
      * [문제 링크](https://leetcode.com/problems/reverse-integer/)
        ```
          reverse integer
          
          StringBuilder랑 try-catch로 해결함
          StringBuilder로 역순으로 문자열 만들었음.
          음수인경우 예외처리 해줌. 1까지만 루프돌아서 -는 안들어가게 함.
            대신 루프 진입전에 - 넣어줘서 음수표현함
          catch로 익셉션 잡았음.
            그래서 Integer.parseInt에서 정수범위 벗어나도 이걸로 잡고 0 리턴함.
          문제풀다가 저지른 실수
            finally에서 return ~~했는데, 이러니까 catch에서 잡고 리턴해도 finally가 문제가 되는 모양.
            그래도 캐치에서 리턴하니까 finally가 실행 안되야 하는게 아닌지 싶은데, 이게 리턴되는 모양임.
            잘 안되더라. finally빼고 try문 마지막에 정상상황에서의 리턴코드 넣고 캐치에도 리턴 넣으니까 잘 됨
        ```
    * **문제3 remove-duplicates-from-sorted-list**
      * [문제 링크](https://leetcode.com/problems/remove-duplicates-from-sorted-list/)
      *  [컬렉션 정리된 포스트](https://gangnam-americano.tistory.com/41)
      *  [해시셋과 트리셋 성능비교](https://dzone.com/articles/hashset-vs-treeset-vs)
        ```
          remove-duplicates-from-sorted-list

          HashSet으로 중복검사함. 이 집합에 요소값이 있는지 확인, 없으면 추가. 있으면 해당 요소(노드)를 제거
            HashSet의 Add, Remove, Contains는 O(1)로 상수시간에 끝남.
          pred와 curr를 전진시키면서 리스트 검사. 최초엔 pred가 null, curr은 head.
            pred가 null이어도 괜찮은게, 첫번째 요소가 제거될 일이 없다. 제거하려면 중복이어야함.
            그래서 첫번째는 제거될 일이 없어서 pred 초기값이 null이어도 동작이 보장된다.
              다만 제거했을 땐, pred는 전진시키지 않는다. curr가 지워졌기 때문이다.
        ```
    * **문제4 palindrome-number**
      * [문제 링크](https://leetcode.com/problems/palindrome-number/)
        ```
          palindrome number
          
          처음엔 큐로 풀었음. 중간까지 큐에 넣고 뒤에서 보면서 같은지 검사했음
          다 풀고 정리하려니까 이게 바보같은 방법이란걸 알았음
          i는 문자열 끝까지 루프돈다. 이와 동시에 j는 문자열 끝부터 --해가면서 후진한다.
            언젠가 i와 j가 만난다. 만났을때 두 문자가 같은지 검사한다.
            안만났을땐 두 인덱스가 가리키는 문자를 비교한다. 다르다면 false리턴
          문제풀때 덤비지 말자. 쉬운문제를 자꾸 이상하게 어렵게 풀면 힘들다.
        ```
    * **문제5 longest-common-prefix**
      * [문제 링크](https://leetcode.com/problems/longest-common-prefix/)
        ```
          longest common prefix

          쉬운 문제였는데 덤비다가 실수해서 오래걸렸다.
          0부터 첫번째 문자열의 길이까지 루프돈다. | i
            ch에 0번문자열의 i번째 문자를 저장
            문자열 배열을 순회한다 | str : strs
              i가 str.length를 침범하는지 검사한다. 얘보다 이상이면, 프리픽스를 비교할 필요도 없다.
              ||
              str의 i번째 문자가 ch랑 다른지 검사한다. 다르면 프리픽스는 거기서 끝이다
              여하튼 이 조건에 걸렸으면 StringBuilder로 문자열 만들어서 리턴하며 끝이다.
          실수했던거 : c-1, 3검사를 따로 하고, c-1에 걸리면 continue하게 짰었다.
          좀 더 세심하게 봤으면 이런 실수 안했을 것. 주의하자
        ```
    * **문제6 linked-list-cycle**
      * [문제 링크](https://leetcode.com/problems/linked-list-cycle/)
        ```
          LinkedListCycle

          Java의 모든 객체의 조상은 Object로, hashCode가 있고, 알아낼 수 있다, 정수값임
          해쉬셋에 방문한 노드의 해시코드를 저장. contains로 검사했는데 있다? 이미 방문한 노드임. 리턴 true
          리스트에 사이클이 없으면 b의 조건문에 안걸리고 루프를 탈출하게 됨.
            이때는 리턴 false하면 된다.
        ```
  * **백준에서 푼 문제 정리**
    * **오큰수 BOJ 17298**
      * [문제 링크](https://www.acmicpc.net/problem/17298)
        ```
        오큰수
        

        처음엔 수열을 스택에 다 집어넣고, 하나씩 팝하면서 TreeSet에 집어넣어서 풀려는 이상한 시도를 했음
            TreeSet의 higher를 이용하려는 거였음 애초에 이렇게 못품. 오큰수를 구하는거임. 최소값이 아니라.
            오큰수는 Ai 오른쪽에 있는 숫자들 중에서 최소값을 구하는게 아님. 
            Ai 우측에 있는 애들중 Ai보다 큰데, 가장 왼쪽에 있는거 구하는거임.
            여하튼간에 이 방법은 틀렸다.

        강의보니까 일케 풀면 되는거였음.
            일단 int[]에 수열을 다 집어넣음
            스택하나 만듬 s. 오큰수 못구한 수를 스택에 넣음.
            앞부터 루프를 돔. i = 0 -> arr.length; i++
                s가 비었으면 여기다가 i 넣고 컨티뉴
                    오큰수 못구한걸 스택에 넣은것.
                안비었으면, 스택이 빌때까지 팝하는 루프에 들어간다
                    팝 하기 전에, 픽부터 해서 arr[i]가 arr[peek]보다 큰지 검사한다
                        크면? arr[i]가 peek의 오큰수인것. arr[peek]에다가 arr[i]값 저장한다.
                            이래도 되는가? 된다. 오큰수를 구한 요소는 다시는 방문 안하니까 괜찮다.
                            마지막으로 팝하면 됨
                        작으면? 오큰수 아니니까 루프 탈출한다.
                            스택 안의 다른 요소들은 검사하지 않아도 되는가?
                                된다. i++ 하면서 검사하고, 오큰수 못구해서 스택에 넣은거다.
                                그래서 스택의 peek에 있는 요소는 스택내의 요소들 중 가장 오른쪽에 있다.
                                얘보다 아래에 깔린 요소들은 얘보다 값이 크다.
                                만약 작았으면 오큰수니까 peek가 들어갈 때 다 제거되었어야 한다.
                                이러한 오큰수의 성질을 이용해서 풀면 된다.
                여하튼 일케 해서 스택안에 있던 오큰수 못구한 애들에 대한 처리를 하는거고,
                arr[i]에 대한 처리도 해줘야 함
                i+1번째가 arr.length 범위 안이고, i번째보다 값이 크면, 오큰수인것. 
                바로 arr[i]에 arr[i+1]값을 넣고 다음 루프로 가면 됨.
                작으면? 오큰수 아닌거고, i도 오큰수 못구한거니까, 스택에 넣고 다음 루프로 가면 됨.

        음...... 강의 안들었으면 이거 풀 수 있었을까?
        좀 더 고민했으면 가능했을지도 모르겠는데, 초반에 접근을 너무 잘못했다.
        문제를 제대로 읽지 않고 또 덤볐다. 이건 진짜로 고쳐야 함.
        Ai가 1이상 백만 이하라고 써놨는데 멋대로 0~9일거라고 착각한것부터 문제였다.
        진짜 반성해야함.
        ```
  * **ArrayList에 대해 더 알게 된 사실**
    * 중간에 add한다고 항상 메모리 재할당이 발생하지 않는다.
    * capacity가 충분하다면, arrayCopy를 써서 add할 자리부터 우측으로 한칸씩 밀어버린다.
    * 충분하지 않다면 그때 grow()메서드를 호출해서 더 큰 배열을 할당받고 복사한다.
    * 다시말해서, 매번 재할당이 발생하는건 아니라는거다. 맨 앞에 넣건, 중간에 넣건,  
      capacity만 충분하면 arrayCopy만 한다.
    * 참고로 ArrayList의 멤버변수 size는 요소의 개수이다.  
      capacity는 ArrayList내부의 배열인 elementData.length를 말한다.

***

## 3.일일퀘스트
  - [x] 알고리즘 공부
  - [ ] 토익 공부

***

## 4.코딩일일결산
* **GOOD**
  * 
* **BAD**
  * 
* **정리하거나 공부해야 하는 것들**
  * 자바 컬렉션에 대해 정리하고 공부하기
  * 컴퓨터구조 ( 오퍼랜드 수에 따른 명령어의 분류 )
  * 링킹과 로딩에 대한 정리
  * 가상머신의 세가지 네트워크 구성법에 대한 정리(호스트랑 브릿지 남음)
  * 퍼블릭, 프라이빗 키를 이용해서 리눅스 서버에 접속하는 방법을 찾고 실습해보기
  * 알고리즘 문제풀기
  * 영어 강의듣기