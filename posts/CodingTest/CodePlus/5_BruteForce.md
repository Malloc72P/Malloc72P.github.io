---
sort: 8
title: 알고리즘 기초 : 브루트 포스
tags: [ 알고리즘, 백준 ]
---

## CodePlus 알고리즘 : 브루트 포스

* 가능한 모든 경우의 수를 다 시도해보는 방법을 브루트 포스라고 한다.
* 자물쇠의 비밀번호가 될 수 있는 모든 경우를 다 입력해서 열면, 브루트 포스 방식으로 따는 것이다.
* 모든 경우의 수를 다 시도해보는거라서 모든 문제를 풀 수 없다. 너무 오래걸린다면, 그건 못푸는것이다.

### 브루트 포스로 문제푸는 단계

* 사람이 직접 문제의 모든 경우의 수를 계산해본다. 계산해보고, 브루트포스로 풀 수 있을지 말지를 판단하자.
* 모든 경우의 수를 만들어낸다.
* 만들어낸 경우의 수로 문제를 풀어본다.

모든 경우의 수를 만들어내는 방법은 여러가지가 있다.

* for문 사용
* 순열 사용
* 재귀호출 사용
* 비트마스크 사용

아저씨 말로는 재귀호출쓰면 웬만한건 다 된다고 한다.

시간복잡도는 O(경우의 수 * 방법 하나당 걸리는 시간)이라고 한다.

### 경우의 수

* n명의 사람이 한줄로 선다면, `n * (n-1) * (n-2) * ... * 1`이 된다.
  * 한명 세우고, 세운 한명 제외하고 세우는 식이라, 결과적으로 `n!`이 된다.
  * `n!`의 경우, `11!`만 되도 1억에 근접한다. 이때 경우당 문제푸는 시간이 n이라도 된다면 `n*n!`이라서, 거의 풀 수 없게 된다.
  * 보통 `n!`이면 `n <= 10`이라고 한다.
* n명의 사람 중에서 대표 두명을 뽑는다면, `nC2`로 표현할 수 있다. 세명이라면 `nC3`이다.
  * 각각 `n(n-1)/2!`, `n(n-1)(n-2)/3!`이라서, 각각 `O(N^2)` `O(N^3)`이다.
* N명의 사람이 있을 때, 각 사람이 영화를 볼지 말지를 결정할 때, 가능한 조합의 수
  * 각각 볼 수 있고 안볼 수 있으므로, 명당 경우의 수는 2이다. n명있다면 2^n이다.
  * 그래서 `O(2^n)`이 된다.
  * `2^20`이면 `1048576`이 되어서 보통 `2^n`이면 n 제한은 20이라고 한다. 물론 절대적인건 아니다.
* 요점은, 문제를 풀 때, 모든 경우의 수에 대해 문제를 풀면 `O()`가 얼마인지 계산해보고, 브루트 포스를 쓸 수 있는지 아닌지를 판단하고 적용하라는 것이다.

### 재귀호출

* N개중 M개를 뽑는 문제에서 순서가 중요하면 재귀호출을 쓸 수 있다고 하신다.
* 선택과 관련된 문제도 재귀호출을 쓰면 된다고 하신다
* N, N-1, N-2가지 ... 이런식이면 순서가 필요하고 그러면 N!이 된다고 하신다
* 선택은 N가지 중 일부를 선택하거나 하지 않는 조건이 있는 경우라고 한다? 그래서 2^n이라고 하신다.
* 직접 풀어봐야 이해할 것 같다.

#### N과 M(1) boj 15649

* 재귀함수로 어떤 위치에 올 수 있는 수를 결정한다
* 각각의 재귀호출에서 어떤 위치는 바뀌어야 한다. 안그러면 항상 같은 값이 나오니까 바꿔야 한다.
* 그 외에 내가 어떤 위치를 방문했는지 등의 정보를 유지할 필요가 있다.
* 이런건 배열로 처리하면 된다. 근데 배열은 0부터 시작하니까, 그냥 0번째를 낭비하는 방법도 문제풀때는 나쁘지 않은 것 같다.
* 배열로 방문여부를 따지거나, 수열을 만드는 작업은 까다로울 수 있다. 문제 많이 풀어서 익숙해져야 하겠다.
* 아직은 익숙하지 않다. 더 연습하자.

### NM과 K(1) boj 18290

* N X M 배열에서 K개의 셀을 선택하는 문제이다.
* 그래서 nmCk이다.
* N X M 배열인 만큼, visit배열도 2차원으로 하면 된다.

### 1,2,3 더하기 boj 9095

* 정수 n을 1,2,3의 합으로 나타내는 문제이다
* 브루트포스로 그냥 모든 케이스를 다 구해보는것도 풀이방법 중 하나이다
* 각각의 자리에서 선택할 수 있는 숫자는 3개이다. 1, 2, 3 중 하나를 고르면 된다
* 정수 n이 주어진다. 이는 11보다 작은 양수이므로, 최악의 경우 3^10이 된다.
* 재귀호출 편하게 작성하기
  * 인덱스는 그냥 1부터 시작하자. ( 0번째를 낭비한다 )
  * 방문했다고 체크하는건 재귀함수의 맨 앞에서 하자.
  * 방문한 값을 저장하는것도 재귀함수의 맨 앞에서 하자
  * 종료조건은 그 다음에 오도록 하자
  * 재귀함수 종료 후, 방문한 사실을 지워야 한다면, 리턴에서 하자. 해당 인덱스번째의 함수호출에서 자신의 흔적을 스스로 지우고 리턴하도록 하기 위함.

### 암호만들기

* 종료조건을 만드는 것도 중요하지만, 답을 구한 경우인지 검사하는 것도 중요하다
* 답을 구한 경우인지를 확인하는데 필요한 값을 매개변수로 두면 풀 수 있다.

### 퇴사 boj 14501

* 종료조건이 반드시 답일 경우만 가리킬 필요는 없다.
* 있을 수 없는 경우도 종료조건으로 넣을 수 있다. 단, 이때는 답을 구하지 않고, 그냥 끝내기만 한다.
* 