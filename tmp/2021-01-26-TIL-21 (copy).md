---
sort: -21
title: TIL-21, 스물한번째.
tags: [ TIL ]
---

# 오늘 할 일

- [x] 구현한 프로그램 테스트할 것
- [ ] 동기, 비동기, 블록,논블로킹의 정의에 대해 정리해보기
- [ ] 이번 CS10 미션풀면서 배운 내용 정리할 것

# 오늘 배운 내용  



## 요청된 작업의 완료를 어떻게 처리할까?

### Synchronous : 작업요청을 동기적으로 처리한다

요청한 작업이 완료될때까지 **기다린다**. 완료되면 리턴된 결과를 받아서 **완료에 대한 처리작업**을 한다.

### Asynchronous

작업을 **요청만 하고 다른 작업을 처리**한다. **나중에 요청한 작업이 완료되면,** 그때가서 완료에 대한 처리작업을 한다.



```note
동기 비동기 개념이 왜 필요할까?

어떤 작업을 누군가에게 요청했다고 치자. 요청된 작업이 완료되었을 때, 어떻게 처리할까? 그 작업이 완료되었다는걸 어떻게 해야 알 수 있을까?

첫번째 방법 : 그 작업이 완료되기를 기다린다. 완료되어 결과가 리턴되면 그걸 받아서 처리한다.
이 경우가 동기적인 함수라고 생각한다.

근데 이 방법은 한가지 문제가 있다. 만약 그 작업이 오래 걸리는 작업이라면? 

네트워크 요청이나 시간이 좀 걸리는 연산작업이 있다고 치자. 이게 다 끝날때까지 기다린다면, 그 시간만큼 그 스레드는 블로킹된다. 처리할 작업이 많은 상황에서 이렇게 놀고있으면 괜찮은걸까? 안괜찮다. 아무것도 안하고 기다린다는건 그만큼 CPU를 놀게 만든다는걸 의미한다. CPU는 계속해서 쉬지않고 의미있는 일을 해야 한다. 우리는 절대 CPU가 노는 꼴을 볼 수 없다.

그래서 비동기 처리를 위해 필요한건, 시간이 걸리는 작업은 요청만 해야 한다는것이다. 요청만 하고, 다른 작업을 계속 처리해야 한다. 나중에 가서 요청작업이 완료되었을 때, 그때가서 완료에 대한 처리를 해주면 된다.

근데 그 완료는 어떻게 알까? 동기적인 요청은 완료할때까지 기다리면 되는거였으니까 쉽다. 근데 이건? 완료를 어떻게 알지? 아무래도 비동기처리의 어려운 점은 이 부분이 아닐까 라는 생각이 든다. 비동기 작업의 완료를 어떻게 알고, 그 시점에 딱 맞춰서 완료에 대한 처리작업을 해줄 수 있을까?

비동기 작업을 하고 있는 애는 이 작업의 완료를 알 수 있다. 애초에 얘가 일하고 있는거니까, 그 작업의 완료를 알 수 있다. 그러니 얘한테 작업완료시 실행할 콜백함수를 넘기면 되는게 아닐까?
```

## Non-Blocking과 Asynchronous에 대한 내 생각

### non-blocking

논블로킹은 기다리지 않을 뿐이다. 요청을 해도 거의 즉시 결과를 리턴한다. 그럼 시간이 오래걸리는 작업은 어떻게 하라는걸까? 

요청에 대한 결과에 "아직 안끝났음"을 추가하면 된다.

##### 예제 : 편지함에 편지가 왔을까?

블로킹 방식이면 이렇게 된다. 

```
--->(블로킹)편자함에 편지가 올때까지 기다린다...---10년째 기다림...---편지들어옴--->편지를 읽는다
```

편지함에 편지가 들어오지 않으면 저기서 계속 블로킹되어있다. 대기중인 것이다. 10년동안 밥도 못먹고 편지함만 봐서 배가 너무 고프다.

반면 논블로킹 방식이면 이렇게 된다.

```
--->(논블로킹)편지함을 확인한다---안왔네---밥먹어야지---편지함확인---안왔네---밥먹---편지함확인---왔네---편지일기---밥먹---~~
```

편지함을 확인하지만, 블로킹되지 않는다. 논블로킹이니까. 편지없다는 결과가 바로 리턴된다. 그럼 다른 일을 한다. 그 다음에 또 편지함을 확인한다. 논블로킹이니까 즉시 안왔다는 결과가 리턴된다. 다른일을 한다... 이렇게 해서 어떤 작업때문에 블로킹되지 않고 다른 작업도 처리할 수 있다.

어 그러면 비동기는 왜있는걸까?

내 생각엔, 효율의 문제가 아닐까 라는 생각이 든다. 작업의 완료(편지함에 편지가 들어왔다)를 알아채기 위해 끊임없이 확인해야 한다. 프로그래밍으로 치면, 계속해서 루프를 돌면서 넌블로킹 함수를 호출해야 한다. 만약 1억번을 호출했는데 그 중 단 한번을 제외한 모든 경우가 "아직 안끝났다"는 결과라면, 그만큼 CPU를 낭비한 셈이 된다. 대신 비동기 함수를 쓰면, 그 작업이 완료되었을 때 콜백함수가 호출되어 처리해주기 때문에, 논블로킹처럼 매우 잦은 함수호출이 필요없다. 이 점이 비동기함수의 강점이 아닐까 라는 생각이 든다.

### 비동기는 언제 쓸까

##### 통신. 

통신은 시간이 오래 걸린다. 그래서 멍때리면서 응답을 기다릴 수 없다. 기다리지 말고 다른 작업을 하고 있어야 한다.

##### 오래 걸리는 작업

현재 스레드에서 안하고 다른 스레드에게 위임한다. 완료되면 그때가서 처리할 수 있도록 한다.

##### 멀티스레드 개선

적은 스레드로 효율적으로 프로그래밍하기 위해 사용. 블로킹 방식의 개선이 필요할 때. 적절한 스레드 개수를 유지하면서 개발해야 하기 때문이다.

#### 이벤트루프

스택이 비었네? 콜백큐에서 가져와서 올려주고, 하는 일을 이벤트 루프에서 끊임없이 반복한다. 그렇게 해서 콜백함수를 싱글스레드에서 비동기로 처리할 수 있다.

asyncObj.then(cb1).then(cb2)라면, asyncObj함수 자체는 비동기함수로 실행된다고 쳐도, cb1,cb2라는 콜백함수는 비동기함수의 실행흐름에서는 동기적으로 실행되는 함수이다.

#### 이벤트 기반 개발

어떤 이벤트의 이름을 키로, 콜백함수를 값으로 넘긴다. 나중에 이벤트가 발생하면 그때 콜백함수가 실행된다. 이런식으로 개발하는걸 이벤트 기반 개발이라고한다?

button.on("click", printMsg) 이런걸 비동기로 처리한다. 클릭 이벤트가 발생하면 나중에 메서드가 호출되게끔 한다.

### 비동기 프로그램의 개발

#### 단일 책임의 원칙

어떤 역할이 필요한지 정한다.

몇개의 객체가 필요할까? 요구사항명세서를 가지고 분석하면서 객체를 추상화한다.

프로그래밍의 흐름, 시나리오를 써본다.프로그래밍이 복잡하면, 간단한 시나리오를 만들어보는것도 방법이다.

### 코드리뷰

K = 작업큐를 통한 여러 스레드의 비동기처리 구현. + 협업

+ newCachedThreadPool : 필요에 따라 스레드 수가 증가?

## Sync, Async, Blocking, NonBlocking의 차이

[Sync -Async, Blocking-NonBlocking](https://www.youtube.com/watch?v=IdpkfygWIMk)

이걸 보고 정리해보자

### Sync

### Async

### Blocking

### NonBlocking


# 코딩일일결산

#### 내일의 나에게 보내는 전달사항

* 

#### GOOD

* 

#### BAD

* 

