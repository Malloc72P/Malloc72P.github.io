---
sort: -61
title: TIL-61
tags: [ TIL ]
---

# 오늘 할 일

- [x] 코테문제풀기

# 오늘 배운 내용  

### Codeplus : 브루트포스 백트래킹

* boj 2529 부등호
* 확실히, 재귀호출 문제풀 때 그래프를 그려보는게 좋은 것 같다. 
* 추상코드부터 해보려고 하면 잘 안된다. 재귀호출이 익숙하지 않은건지, 어떻게, 뭘 해야 할지가 머릿속에 전혀 그려지지를 않기 때문이다.
* 하지만 그림을 그려보면 뭐가 필요하고, 뭘 어떻게 해야할지가 좀 보인다.



### 코드리뷰 받은 내용을 잊지 말자

* 엔티티의 필드에 속성을 줄 때, 과연 이 속성이면 충분할까? 를 의심하자
* **속성을 전달하기보다 객체를 전달하자**
* 생성자를 통한 의존성 주입을 하자
  * 이러면 final을 쓸 수 있다. final변수는 선언위치가 아니면 초기화할 수 있는 곳이 생성자뿐이다.
  * 물론 의존성이 주입된 변수의 값이 바뀔일이 얼마나 될까 싶지만, 확실히 해줄 수 있다 라는건 장점이다.
  * 또한, 해당 클래스는 이러한 객체가 주입되어야만 한다! 를 표현하는데도 좋을 것 같다
* 옵셔널을 사용함에 있어서, `orElse(null)`보다는 예외를 throw하도록 하자. null값을 만들고 직접 체크하는건 위험할뿐더러 코드의 복잡도를 높일 수 있다.
  * 왜냐하면, 직접 null체크한다는건, 그만큼 컨트롤러와 같은 일반적인 코드에 예외처리코드가 같이 들어간다는걸 의미할 수 있다.
  * 만약 일반코드와 예외처리코드가 같은곳에 혼재되어 있다면, 가독성도 떨어지고, 무엇보다, 실수할 확률을 높인다. 실수하는 순간 `NPE`가 발생한다. 치명적이다
  * 반면 예외를 throw하고, 예외처리 핸들러를 통해 관리해준다면, 예외처리코드를 일반코드로부터 분리시켜줄 수 있다는 장점이 있다.
* 책임분리를 확실히 하자. 컨트롤러는 어떤 요청을 받아서 처리하고, 알맞은 뷰를 찾아서 응답해주는게 컨트롤러의 역할이지만, 처리과정에서 충분히 분리시킬 수 있는 기능도 많다.
  * 가령, 객체의 값을 업데이트하는건,  해당 객체에서 짊어져도 되는 책임이다. 이것까지 컨트롤러에게 맡기는건 올바르지 않다고 생각한다
  * 따라서 이러한 코드가 있다면 최대한 분리시키자. 안그래도 컨트롤러의 책임은 무겁다.
* ID는 웬만하면 최상단에, 필드배치는 적절히.
* 필요없는 어노테이션은 제거
* 중복된 어노테이션인지 의심해보자. 가끔 어노테이션에서 이미 명시해놨을 수 있다. 예를 들면, `HandlebarsHelper`는 이미 `Component`어노테이션을 명시해놓았다.
* static Logger를 쓰도록 하자. 성능상 이점이 존재한다. [링크](https://stackoverflow.com/questions/8262310/any-reason-to-use-private-instead-of-private-final-static-on-the-logback-logger)
* REST API의 URL규칙을 준수하자
* 엔티티에선 Wrapper클래스를 쓰는편이 좋다. 왜냐하면 Nullable을 표현할 수 있기 때문이다.
* 어노테이션에서 비어있는 괄호는 지우자
* 로거로 인해 문자열을 합치는 연산이 발생하는걸 피하자. 쉼표를 써서 해결할 수 있다.
* `href`에 `#`을 쓰지 않도록 하자. 이런 링크를 누르면 페이지 이동은 없지만, 스크롤이 최상단으로 이동한다.
  * `javascript:;`을 쓰면 스크롤 이동없이 `#`대체할 수 있다.
* 예외처리클래스에선 예외를 받아서 처리하도록 구현하자
  * 예외로 받은 정보를 최대한 이용해먹는편이 디버깅할때 큰 도움이 된다.
* 예외의 유형에 대해 고민하자
  * `Checked`, `Unchecked`는 자바의 예외에서 나오는 개념이다. `Checked`는 예외가 컴파일 시점에서 체크되지만, `Unchecked`는 컴파일 시점에서 체크되지 못한다. 그래서 try/catch로 감싸는게 강제되는지 아닌지의 차이가 있다.
  * 우리가 고민해봐야 할 부분은, 스프링에서의 개념이다. 이게 트랜잭션 롤백시점에 대한 개념이 있다고 한다. 그래서 `CustomException`이라고 해도 CheckedException일 경우가 있다. 나중에 트랜잭션 처리할 때 예외처리 공부를 다시 해야 할 것 같다.
* 이게 좋은 이름인지, 언제나 의심하자.
* `Question`의 `isMatchingWriter` 고쳐라
* 실제 수행되는 SQL이 무엇인지를 고려하고 코드를 작성하라. 어차피 덮어쓰는 쿼리라면 굳이 비교연산해서 덮어쓸 필요가 없다. 쿼리를 봐야 불필요한 연산을 줄일 수 있다.
* 가출한 메서드를 잡아와라. `AnswerController`의 `createAnswer`였던 것.
* equals는 `if(!(o instanceof User)) {return false;}`로 검사하는편이 상속구조를 고려했을때의 equals비교에서 좋다고 한다. 나중에 한번 찾아보자. 이펙티브 자바에 이런 내용이 있는 모양이다.
* 접근제어자를 빠뜨린다면 산체로 잡아먹겠다.` ༼ つ ◕_◕ ༽つ`

### 커밋 메시지를 더 잘 써보자

* 다른 사람들이 하는걸 따라가자

* [참고 링크](https://velog.io/@djh20/Git-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90)

* |          설명           |  머릿말  |
  | :---------------------: | :------: |
  |    새로운 기능 작성     |   feat   |
  |        버그 픽스        |   fix    |
  |      빌드파일 수정      |  build   |
  |      문서파일 수정      |   docs   |
  |       코드 리포맷       |  style   |
  |        리팩토링         | refactor |
  | 테스트코드 작성 및 수정 |   test   |








# 코딩일일결산

#### 내일의 나에게 보내는 전달사항

* 미션 4 시작하기
* 더티체킹이 뭔지 공부해보기
* 언젠간 로거 레벨에 대해 공부하기
* [Pyro님 블로그 보고 공부하기](https://www.notion.so/REST-4cebf855900b4b0496acce657b5c8104)

#### 특이사항

* 

