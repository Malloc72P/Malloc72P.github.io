---
sort: -24
title: TIL-24, 스물네번째.
tags: [ TIL, 데이터베이스 ]
---

# 오늘 할 일

- [ ] 오늘 강의때 배운 내용 정리해보기
- [ ] 데이터베이스가 필요한 이유에 대해 정리하기
- [ ] 데베의 트랜잭션에 대해서 정리하기
- [ ] 데베의 인덱싱에 대해서 정리하기
- [ ] 코테공부하기

# 오늘 배운 내용  

## 마스타 호눅스의 시간

### 데이터베이스

데이터가 뭘까

datum의 복수형, datum은 자료라는 뜻

의미를 가지고 있는 것. 또한 기록될수 있는 것.

데이터베이스 : 유한한 데이터의 집합 전기적인 형태로 저장되고, 컴퓨터로 제어할 수 있는 데이터의 집합을 데이터베이스라고 한다.

도서관 컨셉. 컴퓨터로 도서관을 만들어보자

데이터베이스를 관리하는 프로그램 : DBMS. 

엑셀도 데이터베이스인가? 그렇다. 일종의 데이터베이스이다.

그럼 DBMS인가? 관점에 따라 다르다. 데베를 관리해주긴 하니까 DBMS라고 할 수 있겠다ㅣ

### 왜 DBMS를 쓰는가?

#### 영속성

지금껏 휘발성메모리에 데이터를 저장했다. 끄면 날아간다. 근데 남아있어야 한다.

초기의 디비는 네트워크 디비나 하이어라키 디비라고 부름

트리처럼 데이터를 관리한다. 이걸 하이어라키 디비라고 부름

네트워크 디비는 데이터를 그래프 형태로 관리했다. 그 시대 사람들한텐 그게 당연했다.

그래프로 표현하면 좋은것? 지도. 친구목록같은거.

데이터가 다른 데이터의 포인터를 가지고 있는게 당연한 시대였다.

근데 이제 이걸 테이블로 저장하기로 한것

값들의 관계로 저장하기로 한것. 그렇게 해서 나온게 관계형 모델. 릴레이셔녈 모델

그럴싸한데? 하고 만든게 RDBMS.

얘가 선풍적 인기를 끌었다. 그래서 초기엔 DBMS = RDBMS였다.

오라클 mysql 둘다 관계형 DB이다.

데이터 사이엔 관계가 성립, 이걸 이용하는걸 RDBMS라고 한다

세계최초의 데베는 어디서 만들었느냐 = IBM

짐 그레이. IBM의 ???를 만들었다. 시스템 R이라는 DBMS를 최초로 만들었는데, DB2로 바뀌어서 은행에서도 쓴다. 근데 퇴출되는 분위기. IBM의 메인프레임이라는 컴퓨터에서 돌아가는데, 우리가 생각하는거랑 많이 다르다. 여기서 코볼로 개발하다가 자바로 개발하고 있다. 그러다 요즘은 또 유닉스 쓰다가 이제는 오라클 + 자바 + 리눅스를 쓴다. 카카오뱅크는 광고는 mysql쓴다고 하는데, 거짓말임. 절대로 그렇지 않고, 게시판같은거, 돈 제외한거에 쓴다. 돈은 여전히 오라클쓴다. 돈 걸린건 무조건 오라클쓴다. 다른 대체제가 없다. 왜?

신뢰도, 안정성때문이다. 오라클은 이 문제에 대해 책임진다.

인그레스라는 디비도 있었는데, 포스트 뭐시기로 바뀌었다고 어쩌구 sql로 바뀌었다. 여전히 남아있다. 70년대에 만든건데도. ㅇㅇ

재밌는 사실 = 미국꺼는 아직도 코볼쓴다. 요즘은 코볼 프로그래머가 없어서 난리가 났다.

### 관계형 데이터베이스

가령 교수님이랑 대학원생은 주종관계가 생긴다. 이런 관계로 둘을 묶을 수 있다.

예를들면 교수님 테이블의 소유물 필드엔 대학원생이 들어갈 수 있다.

근데 왜 관계형 데베를 쓸까? 왜? 

트랜잭션때문이다.

몽고디비도 트랜잭션이 있긴 한데 별로다

### 관계형 데이터베이스는 트랜잭션을 제공한다

트랜잭션은 ACID의 특성을 간다

원자성, 일관성, 고립성, 안정성을 가져야 한다.

##### Atomicity

아예 안일어나는건 괜찮다. 근데 어중간하게 성공하면 큰 문제가 된다. 아예 다 되던가, 아예 다 되지 말던가

##### Consistency 일관성

통장의 잔고다. 무조건 0 이상이어야 한다고 치자. 그러면 내가 이체하면 중간에 마이너스가 되면 안된다. 절대로.

트랜잭션 전 후에 절대로 우리의 값들이 유효하지 않는 값을 가질 수 없다는 성질이 Consistency이다.

##### Isolation 고립성

여러명이서 같이 써야한다. 근데 마치 싱글스레드에서 돌아간 것 과 같은 결과를 가져야 한다. 싱글스레드와 같은 결과를 보장해줘야 한다. 동시에 실행된다 쳐도 논리적으로는 동기화가 되는 것 처럼 결과가 나와야 한다.

아이솔레이션을 제공하는 가장 쉬운 방법은 싱글스레드로 실행하는 것이다. 그러면 되는데 성능이 나락으로 떨어진다. 실제 디비는 멀티스레드로 병렬처리한다. 그런데도 싱글스레드로 돌아가는것처럼 보장되어야 한다.

짐 그레이의 트랜잭션 프로세싱이라는 책을 읽어보면 좋다. 관계형 디비를 만들려면 이정도는 해야 된다 라는 내용을 담은 책이다.

##### Durability 내구성

한번 저장된 데이터는 손상되어선 안된다. 

### 데베를 왜 쓰는가

쓰기 싫으면 안쓰고 직접 만들면 된다. 근데 데이터의 영속성을 보장하는 개쩌는 프로그램을 만들어야 한다. 안그러면 프로그램 성능이 나락으로 빠지거나 데이터베이스가 망가지는 일이 발생할 것이다. 

내가 만들 수 없고, 만들 수 있다 쳐도 효율이 너무 나락이라서 상용 데베를 쓰는 것이다.

데이터라는건 그저 기록될 수 있는 어떤 사실들. 인포메이션은 유의미한 데이터이다. 조금 더 의미가 있는 데이터라고 보시면 된다. 딸기를 팔았더니 바나나도 많이 팔렸다던가, 그런 유용한 데이터를 인포메이션이라고 한다.

지식은 뭘까? 1월달에는 딸기랑 바나나를 많이 팔렸다. 라던가. 어떤 정보를 이용해서 어떠한 지식이 생기는 것. 이걸 이용해서 작업의 효율을 높일 수 있다.

가령 1월엔 바나나가 많이 팔릴 것이다 라는 것을 추측할 수 있다. 그래왔다는 지식이 있으니까. 이게 인사이트이고 위즈덤이다. 지식을 기반으로 한 통찰력과 지혜가 생긴 것이다.

보통 난리지와 인포메이션은 쿼리로 만든다. 인포는 간단한 쿼리로 만들 수 있고, 난리지는 오래 걸릴 것이다. 데베를 싹싹 뒤져야 얻을 수 있는 것들이 보통이다. 인사이트나 위즈덤같은건? 예전에 거북이 등을 뜯어서 정보를 기록해서 인사이트와 위즈덤을 얻었다. 오늘날은 머신러닝까지 써가면서 얻는다

OLTP와 OLAP

온라인 트랜잭션 프로세싱. 전자상거래, 게시판에 가까운 프로젝트.  초단위 수행시간

온라인 아날리시스 프로세싱. 분산용 어플, 프로그램 쿼리. 긴 시간이 필요하다. 보통 사장님 쿼리라고하는데, 1월 실적이라던가 그런걸 위해서 데이터를 뽑아다 드려야 한다. 이걸 sql로 짜야 하는데, 사용자의 응답성이 중요하냐 이게 중요하냐? 유저가 중요해야 하는데, 우린 사장님을 더 위해야 해서 데베를 하나 더 만든다. 어떤 컴퓨터에 복제해놓고, 메모리 64테라짜리 개비싼 디비가 있는데 그걸로 바꾼다. 시간당 20만원짜리라는데, 얘를 돌려서 실행한다. 금방 나온다. 빨리 하고 빨리 끄면 몇만원이라 생각보다 경제적이고 효율적이다.

그래서 나중에 클라우드도 공부하는게 좋다.

머신러닝은 OLAP랑 비슷하다. 머신러닝과 딥러닝도 뭔가 분석한 결과를 얻고 싶은 것.

머신러닝과 OLAP의 차이는? OLAP라는건 쿼리 짜는게 사람. 사람이 하냐 머신이 하느냐의 차이. 어떤식으로 분석해서 결과를 뽑아올지를 사람이 하는 것. 이게 OLAP. 머신러닝은 어떻게 그런 결과가 나왔는지 모른다?

##### 머신러닝과 딥러닝

ML과 DL도 이제는 알 필요가 있다. 생활코딩의 머신러닝 정도의 학습이라도 매우 좋다.

### NoSQL

Not Only SQL이라는 뜻.

관계형 데이터베이스를 보완.

수평확장 가능, 고성능. 그러나 트랜잭션 기능이 약하다.

중요한건 두가지. 수평확장이란게 뭘까? 서버를 여러대 병렬로 추가가능하다. 규모를 쉽게 늘릴 수 있다. 관계형 디비는 그게 안된다. 수직확장되어야 한다. 비싼 서버를 써야 한다? 그래서 수평확장이 경제적이다. 수직은 더 비싸고 한계가 있다.

관계형 디비의 응답속도는 보통 REDIS는 마이크로초의 응답속도를 가진다. RDBMS는 밀리세컨드 정도를 가진다. 체팅같은걸 RDB에 저장할 수 없다. 왜? 두가지 이유. 성능, 사용자 메세지의 양. 하루에 일억건! 이거 처리하는데 RDB는 적합하지 않다. 근데 돈은 절대 안된다. 오라클써야 한다.

넷플은 NoSQL써서 돈처리한다는데 걔네는 천재니까 그런것

### 빅데이터

뭐가 빅데이터냐. 엄청나게 크다는 정의가 아닌데? 정렬이 안되어있다. 유저 백만명 만든건? 빅데이터 아니다. 겨우 이걸 빅데이터라고 하지 않는다. 페타바이트정도는 되어야. 최소한 백테라는 되어야 빅데이터로 쳐준다. RDB로 처리가 안되면 빅데이터라고 한다.

빅데이터 처리하는 플랫폼으로는 하둡이 매우 유명하다. 하둡 에코시스템. 스파크도 있다.

하급생태계? 하둡 기반으로 여러가지가 돌아간다. 그래서 에코시스템이라고 한다. 일등 오라클, 이등 MySQL 둘다 오라클 거임. 

![image-20210129113435005](image-20210129113435005.png)

보면 대부분 RDBMS이다. 백엔드면 이거 다 알고 있어야 한다. 으아악.

적어도 튜토리얼 정도로는 해봤어야 한다.

여기까지가 반드시 알고 있어야 하는 사실들. 외우고 있어야 한다.

## DBMS가 없다면?

그래서 데베를 구현하기로 했다

#### 뭘 저장해야 하는지 부터 정의

회원정보 ( 아이디, 이름, 비번)

글 ( 제목, 본문 )

#### 어떻게 저장할까?

##### 방법 1 : 디스크에 저장하지 않는다. 디스크가 없다.

문제 : 컴퓨터가 꺼지면 어떻게 할까? 휘발성 메모리이기 때문에 다 날아간다.

정전되면 서비스를 접어야 한다. 로그라이크 서비스가 되버린다.

##### 방법 2 : 디스크를 쓴다.

파일 포맷을 정해야 한다. txt.

어떻게 저장할 것인가. 파일 이름은 user.csv로 하자. board.csv

user.csv는 어떻게 저장하는가.

```
ID, NAME, PASSWORD
kyu, wakyu, steak
pyro, pp, 1234
noel, asdf, 1234
```

```
UID, TITLE, BODY, ARTICLE
kyu, 스테이크, ㅁㄴㅇㄹ
```

괜찮을까?

이걸 이용해서 구현하면?

로그인 절차 = 아이디, 패스워드 전송 > 파일을 읽는다 > 순회하면서 아이디 찾고 확인한다 > 결과 리턴

문제점 : 파일을 읽어야 함. 순회하면서 아이디를 찾아야 함.

매번 파일을 읽는건 너무 느려서 안좋다. 시작할때 메모리에 올려야 한다. 어떤 자료구조에 다 넣어두면 된다. 근데 이러면 주메모리에 너무 큰 데이터를 다 올려야 한다. 불가능할 수 있다.

정렬은? 안된다. 왜? 회원가입할때마다 정렬? 가입할때마다 매번 정렬해야한다. 너무 오래 걸린다.

정렬 안하면 어떻게? 회원가입할 때 마지막에 추가하면 된다. 

주메모리에 올린다는 발상자체는 좋다. 그런데 용량이 걱정이다. 그러면 일부만 메모리에 올리자. 어떤걸 올리느냐, 자주 사용하는 데이터만 메모리에 올리자. 캐싱.



여전히 문제

여전히 디스크에서 데이터를 읽어야 한다. 메모리에 없는 사용자는 전체를 다 읽어야 한다. 메모리에서 쓸 자료구조는 뭘 쓰는게 좋을까? 해시맵. 쓰면 뭐가 좋은가? 아이디 패스워드니까 탐색이 O(1)이다. 좋다.

근데 디스크에 정렬은 안하는데 빨리 읽어야 한다? 알파벳 순으로 파일을 따로 만든다. 파일분할. 이러면 성능이 좋아질 것 같다 . 근데 아니다. 왜? z에 사람이 없다. 고르게 분산되지를 않는다. 여튼 이런 균등분배해서 분할하는걸 샤딩이라고 부른다. 근데 균등분배는 어렵다.

##### 자료구조를 바꿔야 한다. 

별도의 추가적인 파일을 만든다. 

탐색용 파일을 별도로 만들자. 용량이 매우 작다. 인덱스파일이라고 부르자. asdf유저는 5번 파일에 저장되어 있다고 저장하자. 인덱싱이란건 이러한 인덱스 파일을 만드는것을 말한다.

인덱스파일은 알파벳 순으로 저장해도 된다. 이런식으로 한다고 치자. 인덱스 파일을 찾기도 쉽다. BinarySearch가 되니까. 대충 만들었는데, 원본보다는 빨라졌을 것이다. 이러면 그럭저럭 돌아가는 게시판이 실제로 된다.

##### 추가적인 요소

텍스트 대신 바이너리로 저장한다. 텍스트파일의 저장이 효율적인가 바이너리 파일이 효율적인가? 바이너리가 용량, 성능 면에서 이득이 있다. 그리고 레코드를 나누는 기준이 무엇인가? 사람은 줄바꿈으로 하는데, 이러면 레코드의 크기가 다르다. 천번째 레코드를 찾아갈 수 있는 방법은 읽어서 찾아야 하는데, binaryFile로 하고 레코드 크기를 고정하면, 바로 접근할 수 있게 된다.

인덱스에선 두가지를 저장한다. 아이디 > 페이지, 레코드번호. 이걸 이용해서 어떤 파일에 저장되어있는지 빠르게 찾고, 얼마나 스킵해서 읽으면 되는지 알 수 있다. 레코드 번호 * 레코드 크기만큼 스킵해서 읽으면 바로 레코드가 나올테니 빠르게 읽을 수 있다.

### 실제 디비는?

디비 파일을 하나 만든다.

디비파일을 내부적으로 페이지라는걸로 쪼갠다 = 디비 파일을 고정크기로 쪼갠다. 이걸 페이지라고 부른다. 페이지엔 레코드를 저장한다. 

사실 레코드는 가변크기이다. 고정크기로 저장하면 낭비되는 용량이 너무 많다. 가령 varchar1000이면 1만 써도 999를 더 차지하게 된다. 그래서 가변크기로 한다. 가변길이를 알려면 오프셋이 필요?

인덱스는 B-Tree를 쓴다. key에서 value를 빠르게 찾을 수 있는 저장구조이다.

B-Tree의 키는 PrimaryKey이다. value로는 page번호와 레코드 번호를 써야 한다.

이걸 이용하면 특정 레코드를 빠르게 찾을 수 있다.

bong -> (1,   5)이면, 1번페이지의 5번 레코드를 참조하면 된다는 말. 여기에 데이터가 있다는걸 알았다. 근데 하나의 페이지에서는? 하나하나 읽어야 하는데 이것도 효율이 안좋다. 우리가 테이블을 하나 만들면 비트리가 하나 만들어진다 pk로. 이걸로 레코드를 찾는다. 이걸로 찾았다? offset이 문제다. 뒤쪽에다가 무언가를 넣어두는데, 500 이라고 써있고, 500번째 봉을 찾을 수 있다? 룩업? 오프셋을 기록해둔다? 이 안에서도 전체를 다 읽을 필요가 없다? 5번째 레코드니까 5번째 칸을 뒤지면 어떤 지점에 저장되어있는지 해당 레코드를 읽을 수 있다. 실제 디비가 이렇게 되어있다.

근데 이렇게 알 필요는 없긴 하다.

##### 알아야 하는건?

실제 디비 테이블을 만들면 비트리 인덱스가 하나 만들어진다. pk에 대해서. pk로 데이터를 찾으면 빠르게 찾을 수 있다. 



## 요약

테이블을 만들면 pk로 b-tree 인덱스를 만든다. 인덱싱을 하니까.

데이터는 순차적으로 저장한다. 

기본키로 레코드를 찾으면 아주 빨리 찾을 수 있다.

기본키가 아닌 필드검색을 하면 매우 느려진다. 이름으로 검색하면? 디비 전체를 탐색한다.(Full Scan)

그럼 기본키가 아닌걸로 탐색하려면? 특정 필드에 대해 인덱스를 만든다. 그러면 빨리 찾을 수 있다.

데베는 트랜잭션을 지원해야 하고 인덱스로 검색하는 기능을 넣어줘야 한다.

성능을 더 높이려면? 별도의 캐시를 사용한다.

레디스가 많이쓰이는 이유? 캐싱이 가능하니까.



mysql bulk insert. 대용량 insert할때 쓴다

docker의 cp를 이용하면 그 안으로 파일을 복사할 수 있다.



mysql 5.7 쓰라는 이유. 최신버전은 검색도 안되고 문제 많아서.

백만건은 벌크 인서트

대문자는 sql쓰는사람들이 보통 대문자로 쓰기 때문에.

가상환경에 DBMS설치하는 이유는 데이터가 잔류하기 때문. 데베 지워도 남아있다

컨테이너 생성할 때 볼륨 지정이 가능. 내 로컬 컴의 디렉토리를 도커의 특정 디렉토리랑 연동가능 -v 옵션.

레드햇은 기술지원 비용이 매우 비싸다. 오픈소스는 공짜지만 지원이 비싸다. 우리는 센트쓰는데 외국은 레드햇 많이 씀. 그래서 우리는 센트쓰다가 문제생기면 백엔드를 갈군다. 기술지원 받아야 하는데 엄청 비싸다. 여튼 얘들은 기술지원으로 먹고산다.

책

sql첫걸음을 추천함. 생코 이고잉님꺼랑 호눅스꺼.



# 코딩일일결산

#### 내일의 나에게 보내는 전달사항

* 

#### GOOD

* 

#### BAD

* 눈이 아프다

 