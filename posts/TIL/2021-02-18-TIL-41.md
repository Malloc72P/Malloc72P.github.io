---
sort: -41
title: TIL-41
tags: [ TIL ]
---

# 오늘 할 일

- [ ] PR에 코멘트를 참조해서 코드 수정하기
- [ ] 코테문제풀기
- [ ] 토끼책 읽기
- [ ] SQL책 읽기

# 오늘 배운 내용  

### Java enum

열거형 상수 집합. 묶어놓은걸 enum이라고 한다

어떤 범주 안의 상수를 선언하고 싶을 때, enum을 쓸 수 있다.

무한히 있는건 열거형으로 쓸 수 없다.

사람 이름이라던가, 그런건 안된다.

개수가 너무 많으면 안된다는 말.

근데 너무 많으면 애매해진다.



enum끼리의 연산이 가능하다. 비교연산을 해서 타입체크를 할 수 있다.

c의 경우, 서로 다른 enum끼리의 비교연산이 가능하다. enum이 정수에 대응되기 때문이다?

자바는 서로 다른 enum끼리 비교연산을 시키면 컴파일에러가 발생한다. 두 enum의 타입이 다르게 때문이다. 자바에서의 enum은 단순히 정수형태의 상수값이 아니다?



자바의 enum은 type-safe하다. 그래서 enum자체를 타입으로 쓸 수 있다?



### ==이랑 equals의 차이점

==랑 equals의 차이는?

==은 변수의 값을 비교한다. equals는 객체가 같은지 비교한다. 클래스에서 equals를 오버라이드해서 같은지 비교하는 연산을 수정해줄 수 있다.

레퍼런스 변수에다가 대고 ==로 비교하면, 두 변수가 같은 객체를 참조하고 있는지를 검사한다.

equals를 쓰면 equals에 정의된 대로, 두 객체의 값이 같은지를 검사한다.

값이 같아도 서로 다른 객체일 수 있다. 이 경우 ==를 하면 다르다고 나오고, equals를 하면 같다고 나온다.

그래서 String을 비교할 때, equals로 비교하는게 맞다.

문제는, ==도 컴파일에러가 발생하지 않기 때문에, 나중에 가서 이런 문제를 찾기 어려울 수 있다는 점이다.



### AssertJ

compareTo는 대소비교를 한다. 같으면 0, 앞의 오퍼랜드가 크면 1, 작으면 -1이다?

sort의 경우에도 comparater를 정의할 때, 이런식으로 정의할 수 있다.



### Enum의 대소 비교

enum으로도 대소비교가 가능하다?



### Enum과 종속관계?

어떤 클래스 A안에 enum B를 선언하는 경우는, A에 B가 종속됨을 명확히 하기 위해서이다.

아니면 클래스 A의 패키지를 만들고, 그 안에 enumB를 넣는 방법도 있다.



### Enum을 쓸 때 얻는것과 잃는 것

타입제한이 가능하고 자동완성이 가능하다.

반면 복잡해진다. enum안에 값이 2개정도라면, 안쓰는게 나을지도 모른다?



### Static이나 String을 남발하면 서버가 죽을 수 있다?

왜?



### 데베에 enum을 저장하기 위한 노력

enum객체를 데베에 저장? 수강코드 이런게 enum으로 되니까?

어떤식으로 저장? enum자체가 내부적으로 int니까 int로 저장한다?

varchar로 가능하다.

DB에도 ENUM이 있을 수 있다. 근데 안쓰는게 좋다?

제일 큰 이유는 상수? 상수가 안되는 이유는?

enum으로 데베에 넣었다. 근데 나중에 enum이 변경되었다면? 그래서 enum사이에 상수값이 하나 들어갔다면, 기존에 데베에 2로 들어갔던게 다른 enum값을 가지게 될 것이다.

또 데베를 마이그레이션하게 되면, 다른 데베엔 enum이 없거나 구조가 다를 수 있으니, 쓰지 않는게 좋다.



enum에도 필드를 만들고 생성자를 만드는게 가능하다. 그러면 enum값에 특정값을 지정할 수 있다.

```java
public enum Size{
	SMALL(44), NORMAL(55), BIG(77);
	public final int value
	
	Size(int value){
		this.value = value;
	}
}
```

value object는 중간에 값이 바뀌지 않으니, 이렇게 쓸 수 있다?



### Enum의 ordinal은 안쓰는게 좋다?

근데 Enum상수에서 다음 상수를 획득하고 싶으면, Enum안에 next라는 메서드를 만들고, Ordinal과 모듈로 연산을 이용해서 Enum을 원형 리스트로 취급하면서 다음 상수값을 획득해서 리턴할 수 있다.

여하튼 보통 이거 안쓴다고 한다. 쓸 일이 없을 가능성이 크다. 해당 상수가 몇번째있는지는 언제나 변할 수 있다. 데베에 ordinal값으로 넣어놨는데 중간에 Enum상수가 추가되면, 기존에 데베에 넣어놨던 값은 다른 Enum상수를 가리킨다. 그래서 안쓰는게 좋을 것이다. 대신, Enum에 필드를 추가하고, 여기에 값을 넣어서 처리하면 된다.



### Enum의 생성자는 private이다?

Enum은 JVM이 만들어주는거지 우리가 만드는게 아니다. 그래서 외부에서 생성하는걸 못하게 막으려고 private생성자를 쓴다? 안적혀있어도 생략되어있는것?

안붙여주는게 컨벤션이다?



### Enum에 여러개의 필드를 만들 수 있다

```java
public enum Size{
	SMALL('s', 44), MEDIUM('m', 55), BIG('B', 77);
	public final int value
	
	Size(int value){
		this.value = value;
	}
}
```

enum의 멤버변수에도 final을 반드시 붙여야 하는가? final이 생략되어 있지 않은가?

아니다 붙여줘야 한다. final 안붙여주면, 외부에서 직접 접근해서 값을 바꿔버릴 수 있다.

### 

### Name, Ordinal, valueOf메서드

* Name메서드는 ENUM안에 있는 상수의 이름이 리턴된다
* Ordinal은 해당 상수가 ENUM에서 몇번째인지를 리턴한다
* valueOf는 상수의 이름을 넘기면, ENUM에서 이름이 같은 상수를 리턴한다.



### EnumSet?

이런것도 있는데 나중에 공부해보라고 한다



### Value Object?

불변값만 가지는게 목적인 객체이다.

Value Object들은 보통 == 로 값을 비교할 수 있다.

값이 같으면 같은 객체로 취급한다?

Enum은 일종의 Value Object이다?



### ```List<Object> list = ArrayList<>();```?

내가 필요한건 List이지 ArrayList가 아닐 가능성이 크다.

그러니 인터페이스를 타입으로 쓰고, 원하는 구현체를 넣는편이 좋다?



나는 ArrayList만의 기능을 쓸꺼야! 라고 한다면 타입도 ArrayList를 쓰면 되는데, 그게 아니구 그냥 List만 쓸꺼라면? 그럼 List를 타입으로 쓰는편이 좋다. 이렇게 하면 만약 나중에 구현체를 바꾸더라도, 인터페이스 자체는 바뀌지 않았기 때문에, 문제가 없다.



아 그리구 LinkedList를 구현체로 쓰는 일은 거의 없다. 왜냐면, LinkedList의 장점은 맨앞, 또는 맨 뒤에 추가 삭제하는 비용이 O(1)이기 때문이라서, 보통 구현체로 쓴다면 Queue나 Stack으로 쓰는 경우가 대부분이라 그렇다. 그냥 List를 쓴다면 임의의 위치에 접근하는게 O(1)인 ArrayList가 좋을 것 같다.



### 참조변수와 함수 호출

* c언어는 b언어 다음에 나온 언어라서 c언어이다.

* 함수가 없다보니 전역변수나 분기문, goto문같은걸로 프로그래밍 했다.

* 함수가 나오면서 여러 변화가 생겼다. 매개변수, 지역변수, 리턴값이 생겼고, 스택이 생겼다. 그래서 효율적으로 변수를 관리할 수 있게 되었다. 

* 포인터도 나왔다. 포인터를 이용하면 주소값을 가지고 연산을 할 수 있다. 주소값으로 참조해서 읽을 수 있다. 함수를 쓰면 이게 필요하다. 왜냐하면, 매개변수는 값을 복사하기 때문에, 함수에서 그 값을 바꿔도, 호출한 함수쪽에서, 매개변수로 넘긴 변수의 값은 바뀌지 않는다. 값을 복사한것일 뿐, 전혀 다른 변수이기 때문이다.

* 함수에 넘기는 실제 값이 아규먼트. 액츄얼 패러미터라고도 부른다.

* 패러미터는 입력값으로 받은 매개변수를 말한다.

* `swap(a, b)`를 하면, a, b값이 복사되므로, `swap(3, 5)` 이렇게 된다. 이때 3, 5가 아규먼트가 되고, 

  `void swap(int a, int b)`에서 a, b가 패러미터가 된다.

* 그래서 포인터를 이용하면 호출된 함수에서도, 호출자의 변수값을 바꿔버릴 수 있다. 다만 이러면 순수함수는 아니게 된다. 외부에 영향을 주니까.

* 함수에 매개변수를 넘길 때, 구조체를 쓴다면, 구조체 전체에 대한 복사가 발생한다. 매개변수는 새로운 변수를 만들고 값을 복사하니까. 그래서 이런 경우엔 포인터만 넘기기도 한다. 그러면 딱 포인터변수의 크기만 복사가 발생한다. 그러면서도 주소참조를 통해 원하는 구조체의 값에 접근해서 읽을 수 있다.

* 근데 이런식으로 어떤 함수를 Call By Ref로 쓰면, 얘로 인해 아규먼트로 넘긴 레퍼런스가 가리키는 객체의 값이 바뀔지 아닐지 알기 힘들어진다. 그러므로, 엄격하게 final을 부여해서 허용되지 않는 변경을 원천봉쇄하거나, private으로 접근제한을 두고, get/setter로만 수정할 수 있도록 제한하는것도 방법이다.

[GFG : Call by value와 call by reference의 차이](https://www.geeksforgeeks.org/difference-between-call-by-value-and-call-by-reference/)





### 새로 알게 된 사실

* Optional은 범용적인 Maybe타입이 아니다.
  * [Java Optional 바르게 쓰기](http://homoefficio.github.io/2019/10/03/Java-Optional-%EB%B0%94%EB%A5%B4%EA%B2%8C-%EC%93%B0%EA%B8%B0/)
* idx같은 축약어는 안좋을 수 있다. 원래 이름이 그다지 길지 않다면, 축약어 사용을 피하는게 좋겠다.
* 빈 공간을 표현하겠다고 굳이 null을 쓸 필요는 없다. 그냥 객체를 넣되, 해당 객체의 상태가 빈 상태를 표현하게끔 구현한다면, `NullPointerException`으로 부터 안전하면서도, 빈 공간을 표현하는 코드를 작성할 수 있다.

# 코딩일일결산

#### 내일의 나에게 보내는 전달사항

* git 커맨드로 업스트림 저장소에서 특정 브랜치만 fetch받는 방법 재정리하기
* 파이로님이 말해주셨던 거 찾아보기.  JVM한대에서 여러개의 자바 프로그램을 실행하는거.

#### GOOD

* 아침에 나가서 운동하기 시작했다. 기분이 상쾌하다.

#### BAD

* 

