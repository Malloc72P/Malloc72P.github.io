---
layout: post
title: TIL-8, 여덟번째.
feature-img: "assets/img/feature-img/DSC00168.jpg"
thumbnail: "assets/img/thumbnails/feature-img/DSC00168.jpg"
tags: [ TIL, 알고리즘, 자료구조, CodePlus, Leet, 백준 ]
---

## 1.오늘의 컨디션
1. zzz.

***

## 2.오늘은 어땠을까
* **오늘 한 일 요약**  
  * Leet에서 코테문제를 풀었다.
  * ArrayList에 대해 더 공부했다.
  * HashSet의 존재를 알게 되었다.
<br>
* **오늘 배운 내용**  
  * **Leet 에서 푼 문제 정리**
    * **문제1 two-sum**
      * [문제 링크](https://leetcode.com/problems/two-sum/)
      * 이중루프를 돌긴 하는데, 두번째 루프는 i+1부터 배열의 끝까지 루프를 돈다.
      * a + b나 b + a나 같기 때문에 두번째 루프는 i+1 이전의 요소를 볼 필요가 없다. 이미 검사해서 그렇다.
    * **문제2 reverse-integer**
      * [문제 링크](https://leetcode.com/problems/reverse-integer/)
        ```
          reverse integer
          
          StringBuilder랑 try-catch로 해결함
          StringBuilder로 역순으로 문자열 만들었음.
          음수인경우 예외처리 해줌. 1까지만 루프돌아서 -는 안들어가게 함.
            대신 루프 진입전에 - 넣어줘서 음수표현함
          catch로 익셉션 잡았음.
            그래서 Integer.parseInt에서 정수범위 벗어나도 이걸로 잡고 0 리턴함.
          문제풀다가 저지른 실수
            finally에서 return ~~했는데, 이러니까 catch에서 잡고 리턴해도 finally가 문제가 되는 모양.
            그래도 캐치에서 리턴하니까 finally가 실행 안되야 하는게 아닌지 싶은데, 이게 리턴되는 모양임.
            잘 안되더라. finally빼고 try문 마지막에 정상상황에서의 리턴코드 넣고 캐치에도 리턴 넣으니까 잘 됨
        ```
    * **문제3 remove-duplicates-from-sorted-list**
      * [문제 링크](https://leetcode.com/problems/remove-duplicates-from-sorted-list/)
      *  [해시맵 ](https://gangnam-americano.tistory.com/41)
      *  [https://dzone.com/articles/hashset-vs-treeset-vs](https://dzone.com/articles/hashset-vs-treeset-vs)
        ```
          remove-duplicates-from-sorted-list

          HashSet으로 중복검사함. 이 집합에 요소값이 있는지 확인, 없으면 추가. 있으면 해당 요소(노드)를 제거
            HashSet의 Add, Remove, Contains는 O(1)로 상수시간에 끝남.
          pred와 curr를 전진시키면서 리스트 검사. 최초엔 pred가 null, curr은 head.
            pred가 null이어도 괜찮은게, 첫번째 요소가 제거될 일이 없다. 제거하려면 중복이어야함.
            그래서 첫번째는 제거될 일이 없어서 pred 초기값이 null이어도 동작이 보장된다.
              다만 제거했을 땐, pred는 전진시키지 않는다. curr가 지워졌기 때문이다.
        ```
    * **문제4 palindrome-number**
      * [문제 링크](https://leetcode.com/problems/palindrome-number/)
        ```
          palindrome number
          
          처음엔 큐로 풀었음. 중간까지 큐에 넣고 뒤에서 보면서 같은지 검사했음
          다 풀고 정리하려니까 이게 바보같은 방법이란걸 알았음
          i는 문자열 끝까지 루프돈다. 이와 동시에 j는 문자열 끝부터 --해가면서 후진한다.
            언젠가 i와 j가 만난다. 만났을때 두 문자가 같은지 검사한다.
            안만났을땐 두 인덱스가 가리키는 문자를 비교한다. 다르다면 false리턴
          문제풀때 덤비지 말자. 쉬운문제를 자꾸 이상하게 어렵게 풀면 힘들다.
        ```
    * **문제5 longest-common-prefix**
      * [문제 링크](https://leetcode.com/problems/longest-common-prefix/)
        ```
          longest common prefix

          쉬운 문제였는데 덤비다가 실수해서 오래걸렸다.
          0부터 첫번째 문자열의 길이까지 루프돈다. | i
            ch에 0번문자열의 i번째 문자를 저장
            문자열 배열을 순회한다 | str : strs
              i가 str.length를 침범하는지 검사한다. 얘보다 이상이면, 프리픽스를 비교할 필요도 없다.
              ||
              str의 i번째 문자가 ch랑 다른지 검사한다. 다르면 프리픽스는 거기서 끝이다
              여하튼 이 조건에 걸렸으면 StringBuilder로 문자열 만들어서 리턴하며 끝이다.
          실수했던거 : c-1, 3검사를 따로 하고, c-1에 걸리면 continue하게 짰었다.
          좀 더 세심하게 봤으면 이런 실수 안했을 것. 주의하자
        ```
    * **문제6 linked-list-cycle**
      * [문제 링크](https://leetcode.com/problems/linked-list-cycle/)
        ```
          LinkedListCycle

          Java의 모든 객체의 조상은 Object로, hashCode가 있고, 알아낼 수 있다, 정수값임
          해쉬셋에 방문한 노드의 해시코드를 저장. contains로 검사했는데 있다? 이미 방문한 노드임. 리턴 true
          리스트에 사이클이 없으면 b의 조건문에 안걸리고 루프를 탈출하게 됨.
            이때는 리턴 false하면 된다.
        ```
  * **ArrayList에 대해 더 알게 된 사실**
    * 중간에 add한다고 항상 메모리 재할당이 발생하지 않는다.
    * capacity가 충분하다면, arrayCopy를 써서 add할 자리부터 우측으로 한칸씩 밀어버린다.
    * 충분하지 않다면 그때 grow()메서드를 호출해서 더 큰 배열을 할당받고 복사한다.
    * 다시말해서, 매번 재할당이 발생하는건 아니라는거다. 맨 앞에 넣건, 중간에 넣건,  
      capacity만 충분하면 arrayCopy만 한다.
    * 참고로 ArrayList의 멤버변수 size는 요소의 개수이다.  
      capacity는 ArrayList내부의 배열인 elementData.length를 말한다.

***

## 3.일일퀘스트
  - [x] 알고리즘 공부
  - [ ] 토익 공부

***

## 4.코딩일일결산
* **GOOD**
  * 
* **BAD**
  * 
* **정리하거나 공부해야 하는 것들**
  * 자바 컬렉션에 대해 정리하고 공부하기
  * 컴퓨터구조 ( 오퍼랜드 수에 따른 명령어의 분류 )
  * 링킹과 로딩에 대한 정리
  * 가상머신의 세가지 네트워크 구성법에 대한 정리(호스트랑 브릿지 남음)
  * 퍼블릭, 프라이빗 키를 이용해서 리눅스 서버에 접속하는 방법을 찾고 실습해보기
  * 알고리즘 문제풀기
  * 영어 강의듣기