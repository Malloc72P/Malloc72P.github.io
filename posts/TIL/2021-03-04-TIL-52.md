---
sort: -52
title: TIL-52
tags: [ TIL ]
---

# 오늘 할 일

- [ ] 코테문제풀기

# 오늘 배운 내용  



## 웹 서비스 아키텍쳐

### 3 티어 아키텍쳐

* [참고 링크](https://chrisjune-13837.medium.com/web-%EC%9B%B9%EC%84%9C%EB%B2%84-%EC%95%B1%EC%84%9C%EB%B2%84-was-app%EC%9D%B4%EB%9E%80-692909a0d363)

* 서비스는 웹서버, 앱서버, 데이터베이스로 구성된다.
* 웹서버는 정적컨텐츠를 서비스한다.
  * 정적컨텐츠는 HTML, CSS, JS, 이미지, 동영상등을 의미한다.
  * 웹서버로는 아파치, Nginx등이 있다.
* 앱서버는 동적인 컨텐츠를 만들어서 서비스해준다.
  * 앱서버를 다른말로 표현하면 WAS라고 할 수 있다.(Web Application Server)
  * 앱서버로는 톰캣과 WebLogic이 있다.
  * 톰캣과 같은 앱서버는 정적 컨텐츠를 서비스할 수 있다. 하지만 실제로 서비스할때는 이렇게 하지 않는데, 그 이유는 성능과 보안때문이라고 한다.
  * 여기서 말하는 성능은 Throughput을 말한다. 웹서버를 따로 두는것이 왜 성능에 도움이 되는지는 더 공부해보고 알아보도록 하자.
* 데이터베이스는 데이터를 보관하고 관리하는 역할을 담당한다.
  * 데이터베이스가 손상되어도 데이터는 보존되어야 하므로, 주기적으로 백업을 한다.
  * 가능하다면 데이터베이스를 실시간으로 복제해서 사용한다. 이때, 실 서비스에서 쓰고 있는 데이터베이스를 프라이머리 데이터베이스라고 하고, 복제된 데이터베이스는 세컨더리 데이터베이스라고 부른다.

### 지속적인 연결을 유지하지 않는 HTTP

* [참조 링크 1](https://hahahoho5915.tistory.com/32)

* HTTP는 지속적인 연결을 유지하지 않는 프로토콜이다.
* 연결이 지속되지 않으니까 상태를 유지하지 않는다.
* 매번 요청할때마다 처음보는 고객처럼 대하게 된다. 그런데 해당 고객에 대한 상태정보를 유지하고 싶다면 문제가 생긴다. 
  * 예를들면, 컴퓨존을 만든다고 치자. 장바구니에 `I5-10400F`를 담았다. 이제 쿨러를 담아야 하니까 페이지를 이동했다. 근데 HTTP는 지속적인 연결을 유지하지 않는다. 따라서 이런 상태가 유지되지 않으니까, 장바구니에 담았던 CPU가 사라져버렸다. 
  * 또는, 아까 아이디랑 패스워드를 전송해서 로그인했다. 근데 이 상태가 유지되지 않는다면, 인증이 필요한 작업을 할때마다 계속 아이디랑 패스워드를 입력해야 한다.
* 이렇듯 상태유지가 필요한 상황이 생긴다. 이럴 때 쓸 수 있는게 쿠키와 세션이다.

### 쿠키와 세션

* 상태유지를 위해 쓰는 기술에는 쿠키랑 세션이 있다.
* 쿠키는 사용자의 컴퓨터(클라이언트)에 저장되고, 세션은 서버에 저장된다.
* 서버에 저장되는 만큼, 세션을 사용한다는건 서버의 자원을 쓴다는게 되고, 사용자가 많아지면 이것도 부담이 될 수 있다. 그렇다보니, 일부분은 쿠키를 이용해서 관리하면 서버의 부담을 줄여주면서 상태유지가 가능하다.

##### 쿠키

* 상태를 유지하고 싶은 정보가 있다면, 쿠키를 만들고 사용자한테 응답해줄때 실어서 보낸다.
* 사용자의 PC에 수신받은 쿠키가 저장되고, 나중에 서버한테 요청할 때, 쿠키를 실어서 요청한다.
* 서버는 이 정보를 가지고 이전의 상태를 알 수 있다. 예를 들면 서버는 `이 친구가 장바구니에 I5-10400F를 담았었구나` 와 같은 정보를 알 수 있는 것이다.

##### 세션

* 쿠키와는 다르게, 상태유지에 필요한 정보를 서버에 저장한다.
* 클라이언트가 서버에 요청하면, 서버는 Request-Header안의 쿠키 필드를 확인하고, 세션ID를 실어서 보냈는지 확인한다.
* 세션ID가 없으면, 서버는 세션ID를 만들고, 이걸 쿠키에 담아서 클라이언트한테 보내준다.
* 클라이언트는 받은 세션ID를 쿠키를 써서 보관한다.
* 나중에 다시 요청할때, 쿠키로 보관된 세션ID를 요청헤더에 실어서 보낸다.
* 요청을 받은 서버는 세션ID이용해서 세션으로 보관해놨던 이전의 상태를 이용할 수 있다.



### 세션 클러스터링

* [참조링크](https://5equal0.tistory.com/entry/StatefulStateless-Stateful-vs-Stateless-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%99%80-HTTP-%EB%B0%8F-REST)
* [참조링크2](https://circlee7.medium.com/%EC%84%B8%EC%85%98-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81-b79e93bf18cf)

* 사용자 요청이 너무 많은 경우, 한대의 웹서버와 앱서버만으로 처리하기엔 부하가 너무 크다
* 여러대의 웹서버+앱서버를 구축해놓고, 로드밸런서로 부하를 분산해서 처리하도록 하면 된다.
* 이렇게 하면 세션관리하는게 문제가 된다. 세션정보는 서버에 저장된다고 했는데, 서버가 여러대이다. 예전에 서버A한테 요청했는데, 다음 요청은 로드밸런서에 의해 서버B에게 하게 되는 경우, 분명히 세션ID는 발급해줬고, 실제로 서버에 상태유지를 위한 정보가 저장되었으나, 그 다음 요청은 다른 서버에게 했으므로 상태유지가 안된다.
* 이런 경우, 세션 클러스터링을 쓸 수 있다.
* 여러대의 앱서버가 세션을 공유하는 기술이다. 어떤 앱서버에만 세션이 있는게 아니니까 로드밸런서에 의해 이전과 다른 앱서버로 요청하게 되어도, 공유세션에 접근해서 이전의 상태정보를 가져올 수 있다.
* 이를 위해 세션정보를 저장하는 데이터베이스를 따로 두기도 한다. Redis라는 데이터베이스를 이런 일을 위해 쓰는 경우도 있다고 한다.

### 그 외의 대안

* 스티키세션을 쓰면 한번 접속했던 앱서버로 계속 접속하게 할 수 있다. 이러면 세션클러스터링을 하지 않아도, 세션을 통한 상태유지가 가능하다. 그런데 해당 앱서버만 재기동되는 일이 생긴다면, 세션정보가 날아가게 된다. 내 생각엔, 스티키 세션을 쓰면 로드밸런싱에도 문제가 될 것 같다. 부하분산을 위해서 다른 앱서버로 요청을 분산시켜야 하는데, 스티키 세션이라서 다른쪽으로 분산시키지 못하게 된다면, 특정 앱서버에만 부하가 몰리는 상황이 발생할 수 있을 것 같다.
* 아니면 아예 상태유지를 안하는 방법도 있다. 아키텍쳐 자체를 Stateless구조로 만들면, 서버를 증설해도 위와 같은 문제가 없다보니, 스케일링할때 유리하다고 한다.

### Read Replica

* 모든 앱서버가 같은 데이터베이스를 읽고 쓰면 부하가 너무 크다.
* 데이터베이스에 대한 Read Replica를 생성한다. 그리고 데이터베이스 읽기작업은 Read Replica를 대신 읽게 시킨다.
* 보통 쓰기작업보다 읽기작업이 더 많다고 한다. 
* 따라서 Read Replica를 만들어두면 프라이머리 데이터베이스에 대한 부하가 줄어들어서 성능을 향상시킬 수 있다.



## Codeplus

* 수 이어 쓰기1 boj1748

### 로그

* [참조링크](https://shoark7.github.io/programming/algorithm/3-ways-to-get-length-of-natural-number)
* c = log(a,b)가 있을때, b라는 수가 a라는 수의 몇제곱이냐는 것이다.
* 이걸 다시 쓰면, a^c = b가 된다. 어떤 수 b는 밑인 a의 c제곱이니까.
* 3 = log(10, 1000)이다. 
* 이걸 응용하면, 어떤 수의 자릿수를 쉽게 구할 수 있다.
* 가령, 999는 10의 몇제곱일까? 얘는 1000보다는 작으니까, log(10,999)는 3보다 작다.(10^3 = 1000이니까.)
* 실제로 울프럼알파로  계산해보면 log(10, 999)는 2.99이다. 정수값만 얻으면 2이고, 얘의 자릿수가 3임을 알 수 있다. (10^2가 100이니까 로그로 구한 정수값 2를 이용해서 100대의 수라는걸 알 수 있다.)





# 코딩일일결산

#### 내일의 나에게 보내는 전달사항

* TIL에 쓴 내용 정리해서 카테고리화 하기

#### 특이사항

* 
