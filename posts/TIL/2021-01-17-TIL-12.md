---
sort: -12
title: TIL-12, 열두번째.
tags: [ TIL, OOP, CodePlus, 백준 ]
---

## 오늘은 어땠을까

컨디션 : 졸림.

***

#### 오늘 할 일

- [x] 코테문제부터 풀기( 골드바흐의 추측부터 )

- [x] 남은시간은 객체지향에 대해 계속 공부하자.

  객체지향의 사실과 오해라는 책을 읽으면서 내 방식대로 한번 구조화해보자.

  그런 다음 루카스의 학습정리를 보고 글로 정리해보자. 

  오늘 다 하자는게 아니다. 이건 좀 긴 시간을 들여야 할 것 같다.

  * 업캐스팅, 다운캐스팅
  * 간접참조 및 객체지향 5대원칙(단일책임의 원칙 등...)



## 오늘 배운 내용  
### CodePlus 알고리즘 기초 1/2 수학 1-2

#### 골드바흐의 추측

2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능하고, 5보다 큰 모든 홀수는 세 소수의 합으로 표현 가능하다는게 골드바흐의 추측이다.  이는 10^18 이하에서는 참인게 증명되어 있단다.

그래서 백만 이하의 짝수가 주어졌을 때, 이걸 만들 수 있는 소수 a, b를 구하는게 골드바흐의 추측 문제이다.

이것도 에라토스테네스의 체로 풀 수 있다. 이걸로 소수를 싹 구하고 이걸 다 순회하면서, a로 두고, N - a, 즉 b가 소수인지 체로 걸러서 확인하면 된다. 

소수를 구하는 방법은 에라토스테네스의 체 말고도 더 있는데(폴라드로), 실수를 가지고 계산하는 방법은 피하는게 좋은게, 정확한 계산이 나오지 않을 수 있기 때문이다. 그래서 정수만 가지고 계산할 수 있는 방법이 좋다.

#### BOJ 6588 골드바흐

우선 에라토스테네스의 체를 만든다. 이걸 못만들면 시간내에 풀기 힘드니, 체를 만드는걸 안보고 할 수 있어야겠다. 이거 풀땐 안보고 하긴 했지만 약간 비효율적으로 했다. 여튼간에 체를 만들고 나면, 수를 입력받고, 루프를 돌면서 입력받은 수를 만들 수 있는 홀수이면서 소수인 두 정수를 찾아야 한다. 루프는 3부터 n/3+1까지만 돌면 된다.  N = a + b라면, 가장 작은 홀수이면서 소수인건 3이다. a를 3으로 놓으면 b는 N/3이 된다. 나머지가 어떻게 처리될 지 불안해서 안전하게 1을 더해줬다. 여하튼 a가 소수이면서, n-a도 소수이면 찾은거다. 이렇게 풀면 된다.

아 그리고 한가지 중요한 걸 찾았다. StringBuilder로 append할 때, String.format이 편해서 이거 많이 썼는데, 성능상 쓰지 말자. 이렇게 했을 때랑, 문자랑 정수랑 다 따로따로 append했을 때랑 비교하면, 따로따로 append하는게 성능이 훨씬 좋다. 왜 그런지 한번 찾아봐야겠다.

그리고 BufferedWriter랑 System.out.println이랑은 별로 성능차이가 안나는 것 같은데, 정확히 어떤 상황에서 성능차이가 발생하는지도 알아볼 필요가 있겠다.

#### 팩토리얼

브루트포스할 때 중요한 의미를 가진다? 왜? 근데 브루트 포스가 뭐야? 이건 나중에 브루트 포스 공부할때 보자.

N!의 0의 개수는 어떻게 알아낼 까? 팩토리얼은 크기가 너무 커져서, 실제 값을 구해서 0의 개수를 구하기가 쉽지 않다.  그래서 다른 방법을 써서 0의 개수를 알아내는게 좋다.

소인수분해를 해서, 2*5가 몇개인지를 이용하면 된다. 어떤 수의 뒤에 0이 붙으려면 10을 곱해줘야 한다. 곱해서 10을 만들 수 있는건 2 * 5밖에 없다. 1 * 10도 결국 1 * 2 * 5이다.  여하튼 어떤 수를 소인수분해했을 때 2 * 5가 몇개있는지 알아내면 0의 개수도 알아낼 수 있다. 근데 실제로 소인수분해를 해버리면 시간이 너무 오래걸린다.

그리고 또 한가지 사실을 보면, 어떤 수의 팩토리얼은 항상 5의 개수가 2의 개수보다 적다. 그래서 5의 개수만 세어주면 된다. 왜 그럴까? 

```mathematica
10! = 1 X 2 X 3 X 4 X 5 X 6 X 7 X 8 X 9 X 10
```

짝수번째마다 2가 계속 생긴다. 그래서 2보다 5가 훨씬 적다. 그래서 5의 개수만 세어주면 된다는 것이다.

그래도 여전히 소인수분해 없이 5의 개수는 구해야 한다. 어떻게 할까?

100!의 0의 개수를 세야 한다고 치자. 그러면 앞에서 배운 내용처럼, 5의 개수를 전부 세야한다. 원래 100!이면 1 ~ 100까지의 모든 수를 곱해야 하는거고, 이 중에서 5가 몇개있는지 찾으라는 말이 된다. 배수를 이용하면 된다. 우선 5의 배수는 반드시 5가 한번씩은 들어가는 수이다. 100 / 5 = 20이다. 근데 25는? 얘는 5 * 5이고, 5가 2개씩 들어간다. 25의 배수도 몇개인지 세준다. 100 / 25 = 4. 5가 추가로 4개 더 들어가는 것. 5^3은 100을 넘어가니 제외한다. 여튼 이래가지고 5의 개수는 총 24개이다.

#### 조합 0의 개수

nCm의 0의 개수를 구하는 문제이다. n! / ((n-m)! * m!)이니, 위의 0을 구하는 방식을 적용하면 된다고 하는데, 지금 조합에 대해 다 까먹어서, 나중에 순열과 조합을 다시 공부할 때 추가로 봐야 겠다.

#### 연습 : GCD합 BOJ 9613


유클리드 호제법으로 GCD구할 수 있는지랑, 배열을 이중루프로 i,j 쌍이 겹치지 않게 순회할 수 있는지 보는 문제이다. 그리고 재귀로 푸나 안푸나 똑같이 124ms가 걸린다.

근데 이 문제 함정이 하나 더 있는데, sum배열의 범위가 문제다. int로 하면 오버플로우가 발생해서 틀릴 수 있다.
난 최대공약수의 합이래서 괜찮을 줄 알았는데, 괜찮지 않다.
그도 그럴게, 1000000 1000000의 최대공약수는 자기 자신인 1000000이다.
그리고 이 문제는 모든 쌍의 GCD를 구하는거지, 100개의 GCD의 합을 구하는게 아니다.
정수 개수가 총 100개일 수 있다. 내가 짠 코드대로면, 99회의 루프에서 i + 1 < m에 해당하는 횟수로 루프를 이중으로 도는데,
정확히 이걸 몇번돈다고 표현해야 할 지는 모르겠지만, sum의 결과가 21억은 넘기 쉬워보인다.
그래서 long으로 써야 풀 수 있다.

다음은 숨바꼭질 문제부터 풀면 된다.

### 객체지향의 사실과 오해를 더 읽고 기록으로 남겼다.

* [책 읽고 정리하는 페이지](https://malloc72p.github.io/posts/Book/The_essence_of_object_orientation/chapter-1.html)

***

## 코딩일일결산
#### 내일의 나에게 보내는 전달사항

#### GOOD

* 하려던 일은 다 했다. 
* 모바일에서 봐도 크게 문제되지 않도록 문서 양식을 조금씩 개선하고 있다. 원노트쓸땐 들여쓰는게 습관이 돼서 여기서도 그런건데, 적당히 쓰는게 좋겠다.
* 책을 읽고 내 생각으로 정리하는 연습을 하고 있다. 예전엔 그냥 막 읽고 끝났는데, 남는게 없다면, 언젠가 까먹어버릴거라면 무슨 의미가 있는지 잘 모르겠어서 내 글로 정리하고있다. 덕분에 책읽는 속도가 너무 느려졌지만, 이해도 못하면서 읽을거라면 차라리 이 편이 낫지 않을까 라는 생각이 들어서 한번 해보는 중이다. 새로운 시도가 좋은 결과를 낳을 수 있으면 좋겠다.
* TIL을 작성하는 효율이 증가했다. 예전엔 원노트로 쓰고 여기로 옮기면서 오버헤드가 좀 컸는데, 이 과정을 없앤데다가 마크다운으로 글쓰는게 예전보다 익숙해져서 그렇다.

#### BAD

* 하려던 일은 다 했지만, 일의 능률도 좋았는지는 잘 모르겠다. 원래는 매일매일 시간을 쪼개서 컴구도 공부하고 영어도 공부하고 코테도 공부하고 그럴 생각이었는데, 너무 무리였던 것 같다. 생각한것보다 하루가 짧다. 더  효율적으로 공부하는 방법을 찾아야 겠다. 그리고 하루에 이 모든걸 다할 생각은 안하는게 좋겠다. 주 단위로 계획을 세우는 편이 더 낫지 않을까 싶다. 그리고 동시에 이 모든걸 다 공부하려는건 너무 과한 것 같다. 다 해내지 못할 것 같다. 하나씩 하자. 다 잡으려다 다 놓치지는 말자.